## 관계형 데이터 베이스 (relational database)
현재 가장 많이 사용되고 있는 데이터베이스의 종류로, 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다. 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스

많이 사용되는 관계 데이터 모델 DBMS는 Oracle, MySQL, SQL Server 등이 있다.
 
 

### 관계형 데이터 베이스 구성요소

- 테이블(릴레이션) : 데이터를 행과 열의 형태로 구성한 집합. 릴레이션의 튜플들은 유일한 존재여야 한다.

- 데이터베이스 : 관련 있는 데이터를 체계적으로 저장한 것으로 데이터는 테이블 형태로 저장되며, 데이터베이스에는 하나 이상의 테이블이 있을 수 있다. 데이터베이스 이름을 붙인다.

- 필드 : 테이블의 열을 의미하며 칼럼이라고도 한다.

- 레코드 : 테이블에 저장된 한 행의 정보를 의미하며 튜플(tuple)이라고도 한다. 한 행에는 여러 필드의 값이 저장될 수 있다.

- 키(key) 

  - 기본키(Primary Key) : 행을 식별할 수 있는 중복되지 않는 유일한 값, null이 될 수 없다. 
  
  - 보조키(Alternate Key) : 
  후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말한다.
  
  - 후보키  (Candidate Key) :
  기본키, 보조키를 모두 합쳐서 후보키라고 한다. 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 한다.
  
  - 슈퍼키 (Super Key) : 
   한 릴레이션 내에 있는 속성들의 집합으로 구성된 키 이다. 유일성은 만족하지만, 최소성은 만족시키지 못한다.
   
  - 외래키 (Foreign Key) : 다른 릴레이션의 기본 키이며, 한 릴레이션이 다른 릴레이션을 참조하기 위해 사용하는 키다.

### 데이터베이스를 사용하는 이유
데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터들을 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이런 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동되어야 한다. 이때 문제점은 데이터의 종속성과 중복성, 무결성이다. 파일 시스템을 사용하면서 발생하는 문제점을 해결하기 위해 데이터베이스를 사용한다.

1. 데이터의 독립성
   - 물리적 독립성: 데이터베이스의 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다
   - 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다
3. 데이터의 보안성
   - 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다
4. 데이터의 일관성
   - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
5. 데이터 중복 최소화
   - 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다

### 관계형 데이터베이스의 특징

1. 데이터의 분류, 정렬, 탐색 속도가 빠르다.

2. 오랫동안 사용된 만큼 신뢰성이 높고, 어떤 상황에서도 데이터의 무결성을 보장한다.

3. 기존에 작성된 스키마를 수정하기가 어렵다.

4. 데이터베이스의 부하를 분석하는 것이 어렵다.

### 관계형 데이터 베이스 장단점

#### 장점
- 데이터 분류, 정렬, 탐색 속도가 빠르다.
- 사용자는 데이터 저장의 물리적 구조로부터 자유롭다.
- 데이터의 무결성과 신뢰성 보장
- 정규화에 따른 갱신 비용이 적다.

#### 단점
- 데이터 스키마가 사전에 계획되어 있어야 하고 수정이 어렵다.
- 데이터 사이에 상호 관계는 Join을 통해 일어나는데, 성능 문제가 발생할 수 있다.
- 빅 데이터를 스키마에 맞추어 넣을 때 많은 시간 소용.

### 질의어

- DDL(Data Definition Language) : 
  - 데이터 정의어
  - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어
  - CREATE, ALTER, DROP, TRUNCATE(테이블 초기화)

- DML(Data Manipulation Language) : 
  - 데이터 조작어
  - 정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할
  - SELECT, INSERT, UPDATE, DELETE]
  
- DCL(Data Control Language) :
  - 데이터 제어어
  - 데이터베이스에 접근하거나 객체에 권한을 주는등의 역할
  - GRANT, REVOKE, COMMIT, ROLLBACK
  
+) 용어 정리
- DBMS(Database Management System, 데이터베이스 관리 시스템) : 데이터베이스를 운영하고 관리하는 소프트웨어. 대표적으로 MySQL, 오라클(Oracle), SQL 서버, MariaDB 
- 데이터베이스(Database, DB) : 데이터의 저장소
- SQL(Structured Query Language) : 관계형 데이터베이스에서 사용되는 언어. DDL,DML, DCL

## Clustering
여러 개의 DB를 수평적인 구조로 구축하는 방식이다. DB 서버 한 대에 장애 발생시 대비할 수 있는 기법이다. 

장점으로는 하나의 서버가 부담하던 부하를 두 개의 DB가 나눠서 감당하므로 CPU, Memory 자원의 부하도 적어지게 된다.

단점으로는 스토리지 공유에 따른 병목현상이 있을 수 있다. 그리고 이전보다 많은 비용이 발생한다.

- Active - Active Clustering
서버 하나가 죽어도 다른 서버가 역할을 바로 수행하여 중단되는 시간이 없다. 같이 사용되어 CPU와 메모리 이용률을 올릴 수 있다.

- Active - StandBy Clustering
상대적 적은 비용으로 사용 가능하며 StandBy 서버가 Active로 전환되는데 시간이 들어 서버가 중단되는 시간이 있다.

## Replication
여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.
Master Node는 쓰기 작업 만을 처리하며, Slave Node는 Master 노드의 로그 파일을 복사하여 저장하고 읽기 작업 만을 처리한다.

### 특징

#### 장점
- DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다. (트래픽 분산)
- 데이터 백업 효과가 있다.
- DB 쿼리를 병렬적으로 수행할 수 있다.

#### 단점
- 비동기 방식으로 데이터를 복제하기 때문에 master와 slave 서버간의 데이터 불일치가 발생할 수 있다. (데이터 복제  동안에 발생한 트랜잭션은 적용이 불가)

## Sharding
하나의 DB에 데이터가 늘어나면 용량 이슈도 생기고, 느려지는 CRUD는 서비스 성능에 영향을 주게 된다. 그래서 트래픽을 분산할 목적으로 샤딩을 고려할 수 있다.

샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장, 관리하는 방법을 의미한다. Shard Key를 통해 데이터를 분산 시키고 분산된 데이터 베이스를 찾아 조회할 수 있다. 따라서, 방법에 따라 효율성이 결정된다.

분산된 데이터를 shards라고 부르고 이는 database node에 뿌려진다.

+) database node: 데이터베이스의 인스턴스를 말한다. main node는 쓰기, 그 외의 노드는 읽기 전용으로 사용되는 것이 전형적

### 특징

#### 장점

- 특정 DB의 장애가 전면장애로 이어지지 않는다.
- 테이블 데이터가 분산됨으로써 인덱스의 크기가 작아지고 그 만큼 조회 성능이 향상된다.
- 서버의 수평적 확장이 가능하다.

#### 단점
- 프로그래밍, 운영적인 복잡도는 더 높아진다, 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선
  - Scale-in
  - Cache나 Database의 Replication을 적용
  - 테이블의 특정 컬럼만 자주 사용한다면 Vertically Partition(수직 분할) 도 하나의 방법
- 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없다. & 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다. 

### 방법

1. Hash Sharding
Database id를 Hashing 하여 sharding 하는 간단한 기법이다. 장점으로는 알고리즘적으로 분배하기 때문에 별도의 map이 필요 없다. 단점으로는 서버를 추가할 때 reSharding이 발생할 수 있다. (확장성이 좋지 않다.)

2. Directory Based Sharding
shard key와 매칭되는 shard의 정보를 갖고 있는 lookup table을 활용하는 방법이다. 장점으로는 동적으로 shard를 추가하는 것도 비교적 쉽다. 단점으로는 공유되는 lookup table이 손상되면 문제가 발생한다.

### 샤딩과 수평 파티셔닝의 차이
보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 방법을 뜻하며, 샤딩은 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법을 말한다.

## Index

인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조로 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 메모리에 저장해 두는 형태이다.

### Index 특징
인덱스는 항상 정렬된 상태를 유지하기 때문에 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다. 다. 따라서 서비스의 특성상 조회 작업이 빈번하게 발생하는지, 레코드의 수정, 삭제, 삽입 작업이 자주 발생하는지 등을 고려해서 결정해야 한다.

### Index 하기 유리한 경우
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 유리하다.
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼 (Cardinality가 높은 칼럼)

인덱스를 관리하기 위해서 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 또한 정렬된 상태를 계속 유지 시켜줘야 한다는 것은 큰 단점이기 때문에 사용하지 않는 인덱스는 바로 지워줘야 한다.

### Index 자료구조
DBMS 는 인덱스를 관리하는 구조는?

- B+ Tree 인덱스 알고리즘
일반적으로 사용되는 인덱스 알고리즘으로(innodb 기본값),  칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다. 시간 복잡도는  O(log2n)

B+Tree는 B-Tree와는 다르게 leaf노드를 제외하고 데이터를 담아두지않기 때문에 branch에서 많은 key를 수용할 수 있어 트리의 높이가 낮아진다. 또한 leaf노드가 linked list로 연결되어 있어 B-Tree에 비해 노드 순회가 쉽다. 하지만 B+Tree는 데이터 탐색을 위해 leaf노드까지 내려가 확인해야하지만 B-Tree는 root나 branch노드에서 탐색을 중단할 수 있다. 

인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행

- Hash 인덱스 알고리즘
Key-Value 형태를 가지며 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구한다. 매우 빠른 검색 속도를 지원하지만(O(1)) 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위(부등호)를 검색할 때는 해시 인덱스를 사용할 수 없다. , 해시 테이블은 내부적으로 데이터 정렬이 되어 있지 않기 때문이다.


### Clustered index, Non-Clustered index

Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성 할 수도 있다. 제약 조건 없이 테이블 생성시에 인덱스를 만들 수 없으며, 인덱스가 자동 생성되기 위한 열의 제약 조건은 기본키 또는 Unique 뿐이다.

#### Clustered index

Clustered Index를 따로 지정하지 않는 경우 테이블 생성시 하나의 열에 Primary Key를 지정하면 자동으로 Clustered Index가 생성된다.

해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. 데이터 행 자체는 한 가지 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있다. Index Page를(루트 페이지) 키값과 데이터 페이지(루트 페이지) 번호로 구성하고, 검색하고자하는 데이터의 키 값으로 페이지 번호를 검색하여 데이터(루트 페이지)를 찾는다.

#### Non-Clustered index
Non-Clustered Index는 테이블의 데이터를 정렬하지 않은 상태로 별도의 장소에 정렬된 인덱스 페이지를 생성한다. Non-Clustered Index는 테이블 당 여러개 존재 가능하다. 데이터 페이지는 Heap 영역에 존재한다.

루프 페이지를 통해 리프 페이지를 찾고 최종적으로 리프 페이지의 포인터를 통해 데이터 페이지에 접근한다.

#### 비교
- Clustered Index 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다. 하지만 데이터의 입력/수정/삭제 시에도 정렬을 수행하여 입력/수정/삭제 속도는 더 느리다. 
- Clustered Index는 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 데이터 그 자체이다. Non-Clustered index의 리프 페이지는 데이터가 위치하는 포인터(RID)다.
- Clustered Index는 범위 검색에 유리하다. ## Index

인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조로 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 메모리에 저장해 두는 형태이다.

### Index 특징
인덱스는 항상 정렬된 상태를 유지하기 때문에 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다. 다. 따라서 서비스의 특성상 조회 작업이 빈번하게 발생하는지, 레코드의 수정, 삭제, 삽입 작업이 자주 발생하는지 등을 고려해서 결정해야 한다.

### Index 하기 유리한 경우
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 유리하다.
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼 (Cardinality가 높은 칼럼)

인덱스를 관리하기 위해서 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 또한 정렬된 상태를 계속 유지 시켜줘야 한다는 것은 큰 단점이기 때문에 사용하지 않는 인덱스는 바로 지워줘야 한다.

### Index 자료구조
DBMS 는 인덱스를 관리하는 구조는?

- B+ Tree 인덱스 알고리즘
일반적으로 사용되는 인덱스 알고리즘으로(innodb 기본값),  칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다. 시간 복잡도는  O(log2n)

B+Tree는 B-Tree와는 다르게 leaf노드를 제외하고 데이터를 담아두지않기 때문에 branch에서 많은 key를 수용할 수 있어 트리의 높이가 낮아진다. 또한 leaf노드가 linked list로 연결되어 있어 B-Tree에 비해 노드 순회가 쉽다. 하지만 B+Tree는 데이터 탐색을 위해 leaf노드까지 내려가 확인해야하지만 B-Tree는 root나 branch노드에서 탐색을 중단할 수 있다. 

인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행

- Hash 인덱스 알고리즘
Key-Value 형태를 가지며 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구한다. 매우 빠른 검색 속도를 지원하지만(O(1)) 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위(부등호)를 검색할 때는 해시 인덱스를 사용할 수 없다. , 해시 테이블은 내부적으로 데이터 정렬이 되어 있지 않기 때문이다.


### Clustered index, Non-Clustered index

Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성 할 수도 있다. 제약 조건 없이 테이블 생성시에 인덱스를 만들 수 없으며, 인덱스가 자동 생성되기 위한 열의 제약 조건은 기본키 또는 Unique 뿐이다.

#### Clustered index

Clustered Index를 따로 지정하지 않는 경우 테이블 생성시 하나의 열에 Primary Key를 지정하면 자동으로 Clustered Index가 생성된다.

해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. 데이터 행 자체는 한 가지 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있다. Index Page를(루트 페이지) 키값과 데이터 페이지(루트 페이지) 번호로 구성하고, 검색하고자하는 데이터의 키 값으로 페이지 번호를 검색하여 데이터(루트 페이지)를 찾는다.

#### Non-Clustered index
Non-Clustered Index는 테이블의 데이터를 정렬하지 않은 상태로 별도의 장소에 정렬된 인덱스 페이지를 생성한다. Non-Clustered Index는 테이블 당 여러개 존재 가능하다. 데이터 페이지는 Heap 영역에 존재한다.

루프 페이지를 통해 리프 페이지를 찾고 최종적으로 리프 페이지의 포인터를 통해 데이터 페이지에 접근한다.

#### 비교
- Clustered Index 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다. 하지만 데이터의 입력/수정/삭제 시에도 정렬을 수행하여 입력/수정/삭제 속도는 더 느리다. 
- Clustered Index는 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 데이터 그 자체이다. Non-Clustered index의 리프 페이지는 데이터가 위치하는 포인터(RID)다.
- Clustered Index는 범위 검색에 유리하다. (데이터가 인덱스 키로 인해 정렬되어 있기 때문)
