## 관계형 데이터 베이스 (relational database)
현재 가장 많이 사용되고 있는 데이터베이스의 종류로, 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다. 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스

많이 사용되는 관계 데이터 모델 DBMS는 Oracle, MySQL, SQL Server 등이 있다.
 
 

### 관계형 데이터 베이스 구성요소

- 테이블(릴레이션) : 데이터를 행과 열의 형태로 구성한 집합. 릴레이션의 튜플들은 유일한 존재여야 한다.

- 데이터베이스 : 관련 있는 데이터를 체계적으로 저장한 것으로 데이터는 테이블 형태로 저장되며, 데이터베이스에는 하나 이상의 테이블이 있을 수 있다. 데이터베이스 이름을 붙인다.

- 필드 : 테이블의 열을 의미하며 칼럼이라고도 한다.

- 레코드 : 테이블에 저장된 한 행의 정보를 의미하며 튜플(tuple)이라고도 한다. 한 행에는 여러 필드의 값이 저장될 수 있다.

- 키(key) 

  - 기본키(Primary Key) : 행을 식별할 수 있는 중복되지 않는 유일한 값, null이 될 수 없다. 
  
  - 보조키(Alternate Key) : 
  후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말한다.
  
  - 후보키  (Candidate Key) :
  기본키, 보조키를 모두 합쳐서 후보키라고 한다. 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 한다.
  
  - 슈퍼키 (Super Key) : 
   한 릴레이션 내에 있는 속성들의 집합으로 구성된 키 이다. 유일성은 만족하지만, 최소성은 만족시키지 못한다.
   
  - 외래키 (Foreign Key) : 다른 릴레이션의 기본 키이며, 한 릴레이션이 다른 릴레이션을 참조하기 위해 사용하는 키다.

### 데이터베이스를 사용하는 이유
데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터들을 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이런 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동되어야 한다. 이때 문제점은 데이터의 종속성과 중복성, 무결성이다. 파일 시스템을 사용하면서 발생하는 문제점을 해결하기 위해 데이터베이스를 사용한다.

1. 데이터의 독립성
   - 물리적 독립성: 데이터베이스의 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다
   - 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다
3. 데이터의 보안성
   - 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다
4. 데이터의 일관성
   - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
5. 데이터 중복 최소화
   - 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다

### 관계형 데이터베이스의 특징

1. 데이터의 분류, 정렬, 탐색 속도가 빠르다.

2. 오랫동안 사용된 만큼 신뢰성이 높고, 어떤 상황에서도 데이터의 무결성을 보장한다.

3. 기존에 작성된 스키마를 수정하기가 어렵다.

4. 데이터베이스의 부하를 분석하는 것이 어렵다.

### 관계형 데이터 베이스 장단점

#### 장점
- 데이터 분류, 정렬, 탐색 속도가 빠르다.
- 사용자는 데이터 저장의 물리적 구조로부터 자유롭다.
- 데이터의 무결성과 신뢰성 보장
- 정규화에 따른 갱신 비용이 적다.

#### 단점
- 데이터 스키마가 사전에 계획되어 있어야 하고 수정이 어렵다.
- 데이터 사이에 상호 관계는 Join을 통해 일어나는데, 성능 문제가 발생할 수 있다.
- 빅 데이터를 스키마에 맞추어 넣을 때 많은 시간 소용.

### 질의어

- DDL(Data Definition Language) : 
  - 데이터 정의어
  - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어
  - CREATE, ALTER, DROP, TRUNCATE(테이블 초기화)

- DML(Data Manipulation Language) : 
  - 데이터 조작어
  - 정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할
  - SELECT, INSERT, UPDATE, DELETE]
  
- DCL(Data Control Language) :
  - 데이터 제어어
  - 데이터베이스에 접근하거나 객체에 권한을 주는등의 역할
  - GRANT, REVOKE, COMMIT, ROLLBACK
  
+) 용어 정리
- DBMS(Database Management System, 데이터베이스 관리 시스템) : 데이터베이스를 운영하고 관리하는 소프트웨어. 대표적으로 MySQL, 오라클(Oracle), SQL 서버, MariaDB 
- 데이터베이스(Database, DB) : 데이터의 저장소
- SQL(Structured Query Language) : 관계형 데이터베이스에서 사용되는 언어. DDL,DML, DCL

## Clustering
여러 개의 DB를 수평적인 구조로 구축하는 방식이다. DB 서버 한 대에 장애 발생시 대비할 수 있는 기법이다. 

장점으로는 하나의 서버가 부담하던 부하를 두 개의 DB가 나눠서 감당하므로 CPU, Memory 자원의 부하도 적어지게 된다.

단점으로는 스토리지 공유에 따른 병목현상이 있을 수 있다. 그리고 이전보다 많은 비용이 발생한다.

- Active - Active Clustering
서버 하나가 죽어도 다른 서버가 역할을 바로 수행하여 중단되는 시간이 없다. 같이 사용되어 CPU와 메모리 이용률을 올릴 수 있다.

- Active - StandBy Clustering
상대적 적은 비용으로 사용 가능하며 StandBy 서버가 Active로 전환되는데 시간이 들어 서버가 중단되는 시간이 있다.

## Replication
여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.
Master Node는 쓰기 작업 만을 처리하며, Slave Node는 Master 노드의 로그 파일을 복사하여 저장하고 읽기 작업 만을 처리한다.

### 특징

#### 장점
- DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다. (트래픽 분산)
- 데이터 백업 효과가 있다.
- DB 쿼리를 병렬적으로 수행할 수 있다.

#### 단점
- 비동기 방식으로 데이터를 복제하기 때문에 master와 slave 서버간의 데이터 불일치가 발생할 수 있다. (데이터 복제  동안에 발생한 트랜잭션은 적용이 불가)

## Sharding
하나의 DB에 데이터가 늘어나면 용량 이슈도 생기고, 느려지는 CRUD는 서비스 성능에 영향을 주게 된다. 그래서 트래픽을 분산할 목적으로 샤딩을 고려할 수 있다.

샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장, 관리하는 방법을 의미한다. Shard Key를 통해 데이터를 분산 시키고 분산된 데이터 베이스를 찾아 조회할 수 있다. 따라서, 방법에 따라 효율성이 결정된다.

분산된 데이터를 shards라고 부르고 이는 database node에 뿌려진다.

+) database node: 데이터베이스의 인스턴스를 말한다. main node는 쓰기, 그 외의 노드는 읽기 전용으로 사용되는 것이 전형적

### 특징

#### 장점

- 특정 DB의 장애가 전면장애로 이어지지 않는다.
- 테이블 데이터가 분산됨으로써 인덱스의 크기가 작아지고 그 만큼 조회 성능이 향상된다.
- 서버의 수평적 확장이 가능하다.

#### 단점
- 프로그래밍, 운영적인 복잡도는 더 높아진다, 가능하면 Sharding을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선
  - Scale-in
  - Cache나 Database의 Replication을 적용
  - 테이블의 특정 컬럼만 자주 사용한다면 Vertically Partition(수직 분할) 도 하나의 방법
- 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없다. & 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다. 

### 방법

1. Hash Sharding
Database id를 Hashing 하여 sharding 하는 간단한 기법이다. 장점으로는 알고리즘적으로 분배하기 때문에 별도의 map이 필요 없다. 단점으로는 서버를 추가할 때 reSharding이 발생할 수 있다. (확장성이 좋지 않다.)

2. Directory Based Sharding
shard key와 매칭되는 shard의 정보를 갖고 있는 lookup table을 활용하는 방법이다. 장점으로는 동적으로 shard를 추가하는 것도 비교적 쉽다. 단점으로는 공유되는 lookup table이 손상되면 문제가 발생한다.

### 샤딩과 수평 파티셔닝의 차이
보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 방법을 뜻하며, 샤딩은 물리적으로 다른 데이터베이스에 데이터를 수평 분할 방식으로 분산 저장하고 조회하는 방법을 말한다.

## Index

인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조로 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 메모리에 저장해 두는 형태이다.

### Index 특징
인덱스는 항상 정렬된 상태를 유지하기 때문에 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다. 다. 따라서 서비스의 특성상 조회 작업이 빈번하게 발생하는지, 레코드의 수정, 삭제, 삽입 작업이 자주 발생하는지 등을 고려해서 결정해야 한다.

### Index 하기 유리한 경우
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 유리하다.
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼 (Cardinality가 높은 칼럼)

인덱스를 관리하기 위해서 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 또한 정렬된 상태를 계속 유지 시켜줘야 한다는 것은 큰 단점이기 때문에 사용하지 않는 인덱스는 바로 지워줘야 한다.

### Index 자료구조
DBMS 는 인덱스를 관리하는 구조는?

- B+ Tree 인덱스 알고리즘
일반적으로 사용되는 인덱스 알고리즘으로(innodb 기본값),  칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다. 시간 복잡도는  O(log2n)

B+Tree는 B-Tree와는 다르게 leaf노드를 제외하고 데이터를 담아두지않기 때문에 branch에서 많은 key를 수용할 수 있어 트리의 높이가 낮아진다. 또한 leaf노드가 linked list로 연결되어 있어 B-Tree에 비해 노드 순회가 쉽다. 하지만 B+Tree는 데이터 탐색을 위해 leaf노드까지 내려가 확인해야하지만 B-Tree는 root나 branch노드에서 탐색을 중단할 수 있다. 

인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행

- Hash 인덱스 알고리즘
Key-Value 형태를 가지며 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구한다. 매우 빠른 검색 속도를 지원하지만(O(1)) 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위(부등호)를 검색할 때는 해시 인덱스를 사용할 수 없다. , 해시 테이블은 내부적으로 데이터 정렬이 되어 있지 않기 때문이다.


### Clustered index, Non-Clustered index

Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성 할 수도 있다. 제약 조건 없이 테이블 생성시에 인덱스를 만들 수 없으며, 인덱스가 자동 생성되기 위한 열의 제약 조건은 기본키 또는 Unique 뿐이다.

#### Clustered index

Clustered Index를 따로 지정하지 않는 경우 테이블 생성시 하나의 열에 Primary Key를 지정하면 자동으로 Clustered Index가 생성된다.

해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. 데이터 행 자체는 한 가지 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있다. Index Page를(루트 페이지) 키값과 데이터 페이지(루트 페이지) 번호로 구성하고, 검색하고자하는 데이터의 키 값으로 페이지 번호를 검색하여 데이터(루트 페이지)를 찾는다.

#### Non-Clustered index
Non-Clustered Index는 테이블의 데이터를 정렬하지 않은 상태로 별도의 장소에 정렬된 인덱스 페이지를 생성한다. Non-Clustered Index는 테이블 당 여러개 존재 가능하다. 데이터 페이지는 Heap 영역에 존재한다.

루프 페이지를 통해 리프 페이지를 찾고 최종적으로 리프 페이지의 포인터를 통해 데이터 페이지에 접근한다.

#### 비교
- Clustered Index 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다. 하지만 데이터의 입력/수정/삭제 시에도 정렬을 수행하여 입력/수정/삭제 속도는 더 느리다. 
- Clustered Index는 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 데이터 그 자체이다. Non-Clustered index의 리프 페이지는 데이터가 위치하는 포인터(RID)다.
- Clustered Index는 범위 검색에 유리하다. ## Index

인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조로 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 메모리에 저장해 두는 형태이다.

### Index 특징
인덱스는 항상 정렬된 상태를 유지하기 때문에 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다. 다. 따라서 서비스의 특성상 조회 작업이 빈번하게 발생하는지, 레코드의 수정, 삭제, 삽입 작업이 자주 발생하는지 등을 고려해서 결정해야 한다.

### Index 하기 유리한 경우
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 유리하다.
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼 (Cardinality가 높은 칼럼)

인덱스를 관리하기 위해서 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 또한 정렬된 상태를 계속 유지 시켜줘야 한다는 것은 큰 단점이기 때문에 사용하지 않는 인덱스는 바로 지워줘야 한다.

### Index 자료구조
DBMS 는 인덱스를 관리하는 구조는?

- B+ Tree 인덱스 알고리즘
일반적으로 사용되는 인덱스 알고리즘으로(innodb 기본값),  칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), 원래의 값을 이용해 인덱싱하는 알고리즘이다. 시간 복잡도는  O(log2n)

B+Tree는 B-Tree와는 다르게 leaf노드를 제외하고 데이터를 담아두지않기 때문에 branch에서 많은 key를 수용할 수 있어 트리의 높이가 낮아진다. 또한 leaf노드가 linked list로 연결되어 있어 B-Tree에 비해 노드 순회가 쉽다. 하지만 B+Tree는 데이터 탐색을 위해 leaf노드까지 내려가 확인해야하지만 B-Tree는 root나 branch노드에서 탐색을 중단할 수 있다. 

인덱스 탐색은 Root -> Branch -> Leaf -> 디스크 저장소 순으로 진행

- Hash 인덱스 알고리즘
Key-Value 형태를 가지며 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구한다. 매우 빠른 검색 속도를 지원하지만(O(1)) 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위(부등호)를 검색할 때는 해시 인덱스를 사용할 수 없다. , 해시 테이블은 내부적으로 데이터 정렬이 되어 있지 않기 때문이다.


### Clustered index, Non-Clustered index

Index는 열 단위로 생성되는데, 하나의 열에 Index를 생성할 수 있고, 여러 열에 하나의 Index를 생성 할 수도 있다. 제약 조건 없이 테이블 생성시에 인덱스를 만들 수 없으며, 인덱스가 자동 생성되기 위한 열의 제약 조건은 기본키 또는 Unique 뿐이다.

#### Clustered index

Clustered Index를 따로 지정하지 않는 경우 테이블 생성시 하나의 열에 Primary Key를 지정하면 자동으로 Clustered Index가 생성된다.

해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. 데이터 행 자체는 한 가지 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있다. Index Page를(루트 페이지) 키값과 데이터 페이지(루트 페이지) 번호로 구성하고, 검색하고자하는 데이터의 키 값으로 페이지 번호를 검색하여 데이터(루트 페이지)를 찾는다.

#### Non-Clustered index
Non-Clustered Index는 테이블의 데이터를 정렬하지 않은 상태로 별도의 장소에 정렬된 인덱스 페이지를 생성한다. Non-Clustered Index는 테이블 당 여러개 존재 가능하다. 데이터 페이지는 Heap 영역에 존재한다.

루프 페이지를 통해 리프 페이지를 찾고 최종적으로 리프 페이지의 포인터를 통해 데이터 페이지에 접근한다.

#### 비교
- Clustered Index 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다. 하지만 데이터의 입력/수정/삭제 시에도 정렬을 수행하여 입력/수정/삭제 속도는 더 느리다. 
- Clustered Index는 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 데이터 그 자체이다. Non-Clustered index의 리프 페이지는 데이터가 위치하는 포인터(RID)다.
- Clustered Index는 범위 검색에 유리하다. (데이터가 인덱스 키로 인해 정렬되어 있기 때문)

# 정규화

## 이상현상
삽입, 삭제, 수정과 같은 데이터베이스의 상태를 변경하는 작업에서 발생할 수 있는 현상을 의미한다. 정규화를 통해서 이상현상들을 해결할 수 있다.

- 갱신 이상 (Modification Anomaly) : 반복된 데이터 중에 일부만 갱신 할 시 데이터의 불일치가 발생하거나 다른 튜플이 중복되는 현상

- 삽입 이상 (Insertion Anomaly) : 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상

- 삭제 이상 (Deletion Anomaly) : 어떤 튜플 삭제시, 의도하지 않은 다른 데이터까지 삭제되어버리는 현상

## 정규화
이상현상이 존재하는 릴레이션을 분해하는 과정으로 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이다. 구체적으 나쁜 릴레이션의 속성 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 의미한다. 릴레이션은 분해되는 정도에 따라 정규형 단계로 나누어지며 정규형이 높아질수록 이상현상은 줄어든다.

### 함수적 종속성
A와 B를 임의의 애트리뷰트 집합이라고 했을 때,, A값에 의해 B값이 유일하게 정해지는 관계를 말하며, "B는 A에 함수 종속이다"라고 한다. 이때, A를 결정자(Determinant)라고 하고, B를 종속자(Dependant)라고 한다. 함수적 종속성을 판단하여 좋은 릴레이션인지, 나쁜 릴레이션인지 정하게 된다.

- 완전 함수적 종속(Full Functional Dependency)
종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우

- 부분 함수적 종속(Partial Functional Dependency)
릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속되는 경우

- 이행적 함수 종속(Transitive Functional Dependecy)
릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때 이행적 함수 종속이라고 한다. 즉, X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우


### 정규화 단계

#### 제 1 정규화 : 릴레이션 최소 조건
테이블의 애프리뷰트의 도메인이 원자 값(하나의 값)을 갖도록 테이블을 분해하는 것
ex) 김선호 -> order : 베토디, 빅맥

#### 제 2 정규화
제1 정규형을 만족하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되도록 테이블을 분해하는 것 
ex) [기본키: 학번, 과목코드] 학번 -> 학부 | 학번 -> 등록금 (부분함수 종속 제거)

#### 제 3 정규화
제2 정규화를 진행한 테이블에 대해, 이행적 함수 종속을 없애도록 테이블을 분해하는 것
ex) (학번 : 학부 : 등록금) 학번 -> 학부 | 학부 -> 등록금 | 학번 -> 등록금 =>> (학번:학부) (학번:등록금)

#### BCNF 정규화
제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

### 특징
#### 장점
- 데이터베이스의 이상 현상을 막을 수 있다. : 일관성
- 정규화된 데이터베이스 구조에서 새로운 데이터 형의 추가로인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도된다.
- 중복 제거
- 정규화된 테이블의 관계는 현실 세계의 개념들과 관계를 반영한다. (사용자에게 데이터 모델을 더욱 의미있게 제공)

#### 단점
- 릴레이션 분해로 많은 조인 연상이 발생할 수 있다. -> 반정규화

### 반정규화
시스템의 성능 향상을 위해 정규화된 데이터 모델을 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 통합, 중복, 분리하는 데이터 모델링 기법으로, 즉 의도적으로 정규화 원칙을 위배하는 행위이다.

- 테이블이 단순해지고 관리 효율성이 증가
- 검색 기능은 향상되지만, 갱신, 삭제 등의 성능은 낮아진다.
- 데이터의 중복 방지, 무결성 vs 데이터베이스의 성능, 단순화 사이의 우선순위를 잘 조절하여 정규화/반정규화를 수행해야 한다

#### 반정규화의 대상
- 테이블의 조인(JOIN)연산을 지나치게 잦아서 데이터를 조회의 성능이 안 좋을 경우
- 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리해야 하는 경우


## 트렌젝션

트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키기 위해 수행하는 작업의 논리적인 단위이다. 하나의 트랜잭션은  작업의 완전성을 보장해주기 웨해 Commit되거나 Rollback된다.

### 특성 (ACID)

- 원자성 (Atomicity) : 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

- 일관성 (Consistency): 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다. 즉, 데이터 타입이 반환 후와 전이 항상 동일해야 한다.

- 독립성,격리성 (Isolation) : 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

- 영속성,지속성 (Durability) : 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 한다.

### 트랜잭션 상태
- Active: 트랜잭션이 활성화된 상태
- Failed: 트랜잭션 실행에 오류가 발생하여 중단된 상태
- Partially Committed: 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
- Aborted: 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
- Committed: 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

+) Commit : 하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성있는 상태에 있음을 의미한다.
+) Rollback : Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.  Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

### 트렌젝션 격리 수준
여러 트랜잭션이 동시에 작업을 수행할 때 한 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 
트랜잭션의 격리수준이 낮아질수록 동시성이 증가하지만, 무결성, 고립성 등 문제가 발생하고 격리수준이 높아질수록 동시성은 감소하지만, 무결성, 고립성을 지킬 수 있다. 

트랜잭션의 격리수준에 따라 Dirty Read, Non-Repeatable Read, Phantom Read의 문제가 발생할 수 있다.

- Dirty Read : 다른 트랜잭션에서 아직 commit 되지 않은 데이터를 조회하는 문제. 트랜잭션이 rollback시 존재하지 않는 데이터를 참조할 수 있다.
- Non-Repeatable Read : 한 트랜잭션 내에서 같은 행을 여러 번 조회할 때 처음 조회 결과와 다른 경우
- Phantom Read : 한 트랜잭션 내에서 같은 쿼리문이 실행했을 때 이전 select에서 존재하지 않던 레코드가 두 번째 쿼리에서 나타나는 현상. 한 트랜잭션 수행 중 다른 트랜잭션이 새로운 레코드를 삽입함으로써 나타난다.


#### 0단계 Read Uncommitted
트랜잭션에서 변경하는 데이터의 commit, rollback 여부에 관계없이 다른 트랜잭션에 노출한다.
Dirty Read, Non-Repeatable Read, Phantom Read 발생

#### 1단계 Read committed
- Dirty Read 해결 : Commit이 완료된 데이터에 대해서만 조회를 허용한다. 
  - MySQL에서는 READ COMMITTED를 지원하기 위해 언두 로그를 사용한다. 한 트랜잭션에서 데이터를 변경하면 변경전 데이터는 언두 로그에 저장되고, 다른 트랜잭션에서 해당 데이터를 조회할 때 언두 로그에서 변경전 데이터를 조회한다.
- Non-Repeatable, Phantom Read 발생 가능 : 대신 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 있다. 

+) 언두 로그는 트랜잭션의 롤백 대비용으로도 사용된다.

#### 2단계 Repeatable Read
-  Non-Repeatable read 문제를 해결 : 트랜잭션이 시작되기 전에 Commit된 내용에 대해서만 조회 가능. update 된 내용은 정합성이 보장되지만, insert, delete는 보장되지 않는다. 
  - MySQL에서는 이를 제공하기 위해 언두 로그에 트랜잭션 ID를 함께 저장한다. 한 트랜잭션에서 데이터를 변경하면 트랜잭션 ID과 변경 전의 값이 언두 로그에 저장된다. 그리고 다른 트랜잭션이 데이터를 조회할 때 언두 로그에서 자신의 트랜잭션 ID보다 작은 값을 읽어 온다.
- Phantom Read 발생 가능 

#### 3단계 Serializable
단순 읽기 작업에서도 해당 행에 대해서 락을 거는 가장 엄격한 격리 수준. 동시성이 중요한 db에서는 거의 사용하지 않는다.

### 트랜잭션과 락
트랜잭션과 잠금(Lock)은 비슷해 보이지만 사용 목적이 다르다. 
Lock은 공유 자원에 대한 접근 순서를 제어하여 동시성을 보장하기 위한 기능이고, 트랜잭션은 데이터 제어 작업의 완전성을 보장하여 데이터베이스의 무결성을 보장하기 위한 기능이다.

따라서 트랜잭션의 작업이 수행될 때 한 데이터에 대해서 여러 커넥션의 접근을 막기 위해서 잠금을 사용한다.

+)  블로킹(Blocking) : 어떤 프로세스가 자원에 접근하려고 할 때 이미 다른 프로세스가 그 자원을 Lock 하고 있어서 그 Lock이 풀릴 때까지 기다려야 하는 상황

### 트랜잭션을 사용할 때 주의할 점
**데이터베이스 Connection 개수는 제한적이다. 트렌젝션은 Connection을 비교적 오래 소유하고 있을 가능성이 있기 때문에 트랜잭션의 범위를 최소화 하는 것이 좋다. **

## 교착 상태(Deadlock)

여러 개의 트랜잭션을 사용할때 데이터의 동시성을 위해 Lock을 사용하게 되는데, 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하여 무한정 대기하게 되는 상황을 교착상태라고 한다.

### 교착 상태의 빈도를 낮추는 방법
1. 트랜잭션을 자주 커밋한다.
2. 정해진 순서로 테이블에 접근한다. 
3. 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
4. 테이블 단위의 잠금을 획득하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.

### MySQL의 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 데드락을 감시하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그 중 하나를 강제 종료한다. 강제 종료하는 트랜잭션을 정하는 것은 언두 로그의 양이다. 언두 로그의 양이 더 적은 트랜잭션이 일반적으로 롤백의 대상이된다.

## NoSQL

### 배경

인터넷이 활성화되고, 소셜네트워크 서비스 등이 등장하면서 관계형 데이터 또는 정형데이터가 아닌 데이터, 즉 비정형데이터라는 것을 보다 쉽게 담아서 저장하고 처리할 수 있는 구조를 가진 데이터 베이스들이 관심을 받게 되었다. 또한 스토리지 비용이 크게 하락하면서 데이터 중복 감소를 목적으로 복잡하고 관리가 어려운 데이터 모델을 생성할 필요가 줄어들었다.

### 정의
대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 데이터 베이스를 말한다.(관계형 데이터 모델을 지양) 

- 데이터를 여러 테이블에 나누지 않고, 관련 데이터를 동일한 컬렉션에 넣어 조인 없이 사용할 수 있다.
- 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다.
- 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다.

NoSQL 데이터베이스는 데이터 모델에 따라 관계형 데이터 베이스에서 제공하지 못하는 성능과 기술을 제공하며 서비스에 맞는 DB 선택이 중요하다.

대표적으로 MongoDB, redis, HBASE 가 있다.

### 유형

#### 1. Key Value DB
가장 간단한 형태의 NoSQL이며 데이터가 Key와 Value의 쌍으로 저장된다. Value는  이미지나 비디오 등의 어떠한 형태의 데이터라도 담을 수 있다. (데이터 입력 단계에서 검증 로직을 제대로 구현하는 것이 중요)  고속 읽기와 쓰기에 최적화되어 있다.

- 대량의 데이터를 저장해야 하지만 검색을 위해 복잡한 쿼리를 수행할 필요가 없는 사용 사례에 적합하다.
  - 성능 향상을 위해 관계형 데이터베이스에서 데이터 캐싱
  - 장바구니 같은 웹 애플리케이션에서 일시적인 데이터 추적
  - 세션 정보
  - 사용자 데이터 정보 저장 및 조회
- 테이블간 조인을 고려하지 않는다.


하지만 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다. 

대표적인 모델로는 Redis, Amazon Dynamo DB 등이 있다.

+) Session 불일치 :  Scale out 적용 시 하나 이상의 서버가 있는 환경에서 세션을 식별하지 못하는 현상 

#### 2. Document Database
가장 많이 쓰이는 모델로 하나의 키에 하나의 구조화된 트리 데이터 방식으로 문서 (XML, JSON) 를 저장하고 조회한다. 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID(key) 에 대한 인덱스를 생성한다. 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.

- 대부분의 문서 모델 NoSQL 은 B 트리 인덱스를 사용하여 2 차 인덱스를 생성한다.
  -  B 트리는 크기가 커지면 커질수록 쓰기나 삭제 성능이 떨어지므로, 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 
- 중앙 집중식 로그 저장소, 타임라인 저장, 통계 정보 저장 등에 사용된다.
- 관계형 DB에서의 여러개 테이블 데이터를 하나의 Document에 모아둘 수 있다. (Join 기능을 대체)
- 문서 구조는 코드의 객체에 맞춰 조정되고 다양한 필드 값 유형과 강력한 쿼리 언어 덕분에  다양한 사용 사례에 적합하다. 

대표적으로 MongoDB, CoucbDB, CouchBase 가 있다.

#### 3. Column Model
하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.

구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL 은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집합이 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.

#### 3.  Column Database
하나의 키에 구조화된 연관된 데이터들(Column-family)과 각자의 Column-name 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 

대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 

- 지리적으로 여러 데이터 센터에 분산되어 있는 애플리케이션
- 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 

등의 서비스 구현에 적합하다. 

대표적인 NoSQL Column-family Model로는 HBase, Hypertable, 구글에서 Big Table, 페이스북은 Cassandra를 개발했다.

4. Graph Database
데이터를 노드로 표현하며, 노드 사이의 관계를 엣지로 표현하는 그래프 구조를 갖고 있다. 페이스북이나 트위터 같은 소셜 네트워크에서(내 친구의 친구를 찾는 질의 등) 적합하고, 연관된 데이터를 추천해주는 추천 엔진이나 패턴 인식 등의 데이터베이스로도 적합하다.

대표적으로 Neo4J가 있다.

### CAP 이론
분산형 구조는 일관성(Consistency), 가용성(Availability), 분산 허용(Partitioning Tolerance)의 3가지 특징을 보장해야 하는데, CAP 이론은 이 중 2가지 만 만족할 수 있다는 이론이다.  NoSQL은 대부분 이 CAP 이론을 따르고 있다.

- 일관성(Consistency) : 분산된 노드 중 어느 노드로 접근하더라도 데이터 값이 같아야 한다. (모든 노드가 같은 시간에 같은 데이터)
- 가용성(Availability) : 분산된 노드 중 하나 이상의 노드가 실패(Fail)되더라도 다른 노드 영향을 주지 않고 시스템은 정상적으로 동작되야 한다.
- 분산 허용(Partition Tolerance): 클러스터링 노드 간에 통신하는 네트워크가 장애가 나더라도 정상적으로 서비스를 수행한다. 노드 간 물리적으로 전혀 다른 네트워크공간에 위치도 가능하다.

RDBMS는 일관성과 가용성을 보장하고 NoSQL은 가용성이나 일관성중 하나를 포기하고 분산 허용을 보장한다.


### SQL VS NoSQL

#### SQL 장점
- 스키마로 인한 명확하게 정의된 데이터 구조 (정규화), 데이터 무결성 보장
- 관계는 각 데이터를 중복없이 한번만 저장

#### SQL 단점
- 데이터 스키마를 사전에 계획해야 하고 나중에 수정하기 힘들다.
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있다. (성능 저하)
- 대체로 수직적 확장만 가능하다. (하드웨어 향상)

#### NoSQL 장점
- 스키마가 없기 때문에 저장된 데이터를 조정하고 새로운 필드 추가하는데 유연하다.
- 쿼리 프로세싱이 단순화되어 대용량 데이터 처리 성능이 높다. (쿼리 외 다양한 API를 통한 데이터 저장 및 검색이 가능)
- 수직 및 수평 확장이 가능하다.
- RDBMS에 비해 저렴한 비용 (설계, 오픈소스, 분산 및 병렬처리)
- 데이터는 애플리케이션이 필요한 형태로 저장된다. 즉, 데이터를 읽어오는 속도가 빨라진다.

#### NoSQL 단점
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 한다.
- 인덱스 구조, 데이터 중복으로 인한 충분한 메모리가 필요

#### 확장
	하드웨어 강화(Scale up)	수평 확장 가능한 분산 아키텍처(Scale out)
    
    API	SQL 쿼리	객체 기반 API 제공

#### SQL 사용하기 좋은 경우
- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
- 데이터 구조가 명확하고 명확한 스키마가 중요한 경우

#### NoSQL 사용하기 좋은 경우
- 정확한 데이터 구조(스키마)를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 대용량 데이터를 다뤄야 해서 데이터베이스를 수평적 확장이 필요한 경우
- 비정형 데이터를 많이 사용하는 경우
- 초당 동시 처리가 중요한 경우
- 로그 및 이력 등의 단순 기록형 업무


### Redis (Remote dictionary server)

NoSQL로서 Key-value 구조이며, 모든 데이터를 디스크가 아닌 메모리에 저장하고 조회하는 인메모리 데이터 베이스이다. 따라서 빠른 속도를 제공한다. 데이터베이스로 사용될 수 있으며 Cache로도 사용될 수 있는 기술이다.

#### 특징
- 영속성을 지원한다.
  - 다른 서버의 메모리에 실시간으로 복사본을 저장하는 방법
  - 디스크에 직접 저장하는 방법
- 오픈 소스 소프트웨어이다.
- 읽기 성능 증대를 위한 서버 측 복제를 지원
- 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding) 지원
- 문자열, 리스트, 해시, 셋과 같은 다양한 데이터형과 api 기능을 지원한다.
- Single thread (cpu 연산보다 디스크io 시간에 집중, 시간 복잡도를 잘 고려해야 한다.)
- 여러 서버에서 같은 데이터를 공유할 때 많이 사용
- 서버 하나에 여러개의 서버를 띄우는 것이 가능하다.
  - Master - Slave 형식
