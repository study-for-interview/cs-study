# 📌 트랜잭션
## ✅ 트랜잭션의 정의
- 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

##### 예시) 사용자 A가 사용자 B에게 만원을 송금한다.

* 이때 DB 작업
    - 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
    - 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경

- 현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문
  → 이를 통틀어 하나의 트랜잭션이라고 한다.
    - 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`
    - 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`

### ✔ 트랜잭션과 Lock
잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 여기서 자원은 레코드나 테이블을 말한다. 이와는 조금 다르게 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다. 예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.

### ✔ 트랜잭션을 사용할 때 주의할 점
트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

## ✅ 트랜잭션의 특징
1. 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.

2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.

3. 하나의 트랜잭션은 Commit되거나 Rollback된다.

## ✅ 트랜잭션의 성질
### ✔ Atomicity(원자성)
1. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.

2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.



### ✔ Consistency(일관성)
- 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.

- 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.



### ✔ Isolation(독립성,격리성)
- 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.

- 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.



### ✔ Durablility(영속성,지속성)
- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.



## ✅ 트랜잭션 연산 및 상태
### ✔ Commit연산
- Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.



### ✔ Rollback연산
-  Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.

-  Rollback시에는 해당 트랜잭션을 재시작하거나 폐기한다.

## ✅ 트랜잭션의 상태
![](https://images.velog.io/images/kcwthing1210/post/236fcc9b-6238-44af-b23c-0808e7986fcc/image.png)

- 활동(Active) : 트랜잭션이 실행중인 상태

- 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태

- 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태

- 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태

- 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

## ✅ Transaction 관리를 위한 DBMS의 전략
이해를 위한 2가지 개념 : DBMS의 구조 / Buffer 관리 정책
### ✔ DBMS의 구조
![](https://images.velog.io/images/kcwthing1210/post/55755f95-3f95-47d9-b870-7dcde0d860c1/image.png)
- 크게 2가지 : Query Processor (질의 처리기), Storage System (저장 시스템)

- 입출력 단위 : 고정 길이의 page 단위로 disk에 읽거나 쓴다.

- 저장 공간 : 비휘발성 저장 장치인 disk에 저장, 일부분을 Main Memory에 저장

### ✔ Page Buffer Manager or Buffer Manager
- DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리하는 모듈

- Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 가져온다.

### ✔ UNDO
- 필요한 이유 : 수정된 Page들이 Buffer 교체 알고리즘에 따라서 디스크에 출력될 수 있음.
- Buffer 교체는 transaction과는 무관하게 buffer의 상태에 따라서 결정됨. 이로 인해, 정상적으로 종료되지 않은 transaction이 변경한 page들은 원상 복구 되어야 하는데, 이 복구를 undo라고 함.

- 2개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)

    - steal : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
        - 대부분의 DBMS가 채택하는 Buffer 관리 정책
        - UNDO logging과 복구를 필요로 함.

    - ¬steal : 수정된 페이지들을 EOT (End Of Transaction)까지는 버퍼에 유지하는 정책
        - UNDO 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함.

### ✔ REDO
- 이미 commit한 transaction의 수정을 재반영하는 복구 작업

- Buffer 관리 정책에 영향을 받음

- Transaction이 종료되는 시점에 해당 transaction이 수정한 page를 디스크에 쓸 것인가 아닌가로 기준.

- FORCE : 수정했던 모든 페이지를 Transaction commit 시점에 disk에 반영
    - transaction이 commit 되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요 없음.
- ¬FORCE : commit 시점에 반영하지 않는 정책
    - transaction이 disk 상의 db에 반영되지 않을 수 있기에 redo 복구가 필요. (대부분의 DBMS 정책)

# 🧩 Reference
- https://coding-factory.tistory.com/226
- https://wonit.tistory.com/462
- https://gyoogle.dev/blog/computer-science/data-base/Transaction.html

# 📌 데드락(Deadlock) 이란?
- 시스템 자원에 대한 요구가 뒤엉킨 상태

즉, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 일컫습니다.

# 📌 데드락의 발생조건
## ✔ 상호 배제
한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
## ✔ 점유 대기
자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
## ✔ 비선점
이미 할당된 자원을 강제로 빼앗을 수 없다(비선점).
## ✔ 순환 대기
대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

# 📌 데드락(Deadlock)의 해결법

## ✔ 데드락 예방(Prevention)
데드락의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것이 데드락을 예방하는 방법입니다. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

- 자원의 상호 배제 조건 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
  그러나 추후 동기화 관련 문제가 발생할 수 있다.
- 점유 대기 조건 방지 : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.

- 비선점 조건 방지 : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
- 순환 대기 조건 방지 : 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.
  이러한 조건을 방지해서 데드락을 예방하는 방법은 시스템의 처리량이나 효율성을 떨어트리는 단점이 발생할 수 있다.

## ✔ 데드락 회피(Avoidance)
시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 안정 상태(safe state)에 있다고 말한다.

그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서(safe sequence)라고 부른다.

반면 불안정 상태는 안정 상태가 아닌 상황을 말합니다. 즉, 데드락 발생 가능성이 있는 상황이며, 교착 상태(데드락)는 불안정 상태일 때 발생할 수 있습니다. 불안정 상태가 교착 상태보다 좀 더 큰 집합입니다.(즉, 교착 상태가 불안정 상태의 부분집합)

이처럼 회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징이다.

이러한 특징을 살린 알고리즘의 예시로 은행원 알고리즘이 있다.



🔑 은행원 알고리즘(Banker’s Algorithm)
다익스트라가 제안한 기법으로, 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사합니다. 즉 대기중이 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것입니다.

어떤 자원 한 가지에 대해서 은행원 알고리즘을 시뮬레이션 해보고자 합니다.

처음에 시스템이 총 12개의 자원을 가지고 있다고 가정해 보겠습니다.

![](https://images.velog.io/images/kcwthing1210/post/bf75e1e6-5364-4071-9dd3-cab8d99c41c3/image.png)
- P0~P2 : 프로세스
- Max :  각 프로세스마다 최대 자원 요청량
- Allocation : 현재 프로세스에 할당 중인 자원의 양
- Need : 남은 필요한 자원의 양(Max-Allocation)

현재 t0일 때 프로세스에 할당된 자원의 합은 5+2+2=9개 이다. 따라서 현재 Available 자원은 12 - 9 = 3개 이다.

순서가 <P1, P0, P2> 일 때 안전 순서를 만족한다.

- P1은 2개가 이미 할당되어 있고, 2개를 추가적으로 할당받기를(Need) 기다리고 있다. 현재 Available 자원은 3개이므로, 이 중에 2개를 P1에게 할당해 준다 => 현재 Available은 3 - 2 = 1개
- 실행이 끝난 P1은 자신에게 할당되어 있던 자원 4개를 모두 반납한다 => 현재 Available은 1 + 4 = 5개

- 현재 Available 자원이 5개이고, 이를 P0에게 모두 할당해 주면 P0도 실행 가능해진다. => 현재 Available은 5 - 5 = 0개 가 됩니다.
- 실행이 끝난 P0은 자신에게 할당되어 있던 자원 10개를 모두 반납한다. => 현재 Available은 0 + 10 = 10개
- 마지막으로 P2에게 자원 7개를 할당해 준다. => 현재 Available은 10 - 7 = 3개
- 실행이 끝난 P2는 자신에게 할당되어 있던 자원 9개를 모두 반납한다. => 현재 Available은 3 + 9 = 12개
  이렇게 자원의 부족함 없이 올바르게 할당하여 모든 프로세스가 실행을 할 수 있었습니다.

❗ 만약 여기에서 P2 프로세스가 처음에 자원을 하나 더 할당받고 있었다면(즉, 2개가 아니라 3개) 운영체제가 가지고 있는 Available 자원은 12 - (5+2+3) = 2개 였을 것이다.

이 상황에서는 처음에 P1에게 2개를 모두 주고, P1이 실행이 끝나고 자원을 모두 반납해도 Available 자원은 2 + 2 = 4개 뿐이므로, 이 자원으로는 나머지 P0이나 P2 프로세스를 해결해 줄 수 없다. (모두 4개보다 많은 양의 자원을 필요로 하고 있으므로)

따라서 P0, P2는 자원을 할당받기를 계속 기다려야 할 것이다.

운영체제가 사전에 P2 프로세스가 자원을 하나 더 요청했을 때 할당해 주지 않고, P1이 먼저 끝나게 한다면 데드락이 발생하지 않았을 것이다. 은행원 알고리즘을 통해 이러한 부분이 해결 가능하다.

그러나 은행원 알고리즘의 경우, 이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재한다.


## ✔ 데드락 탐지(Detection) 및 회복(Recovery)
먼저 시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 데드락을 탐지하고, 회복하는 알고리즘을 사용한다.

- 탐지 기법
  Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.
  이 외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다.
- 회복 기법
    - 단순히 프로세스를 1개 이상 중단시키기
        -  교착 상태에 빠진 모든 프로세스를 중단 시키는 방법 : 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 겨로가가 폐기가 될 수 있는 부작용이 발생 할 수 있음
        - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법 : 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
    - 자원 선점하기
        - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법
    
# 🧩 Reference
- https://chanhuiseok.github.io/posts/cs-2/
