# 🎁 유저 커널 모드
# 📌 필요성
우리가 흔히 사용하는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 동작한다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법이 필요하다.


하드웨어 적인 보안을 유지하기 위해 운영체제는 기본적으로 두가지 모드를 제공하는데 커널모드(kernel mode, system mode), 사용자 모드(user mode)가 이에 해당한다.

- **커널 모드** : 운영체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드로서 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다

- **유저 모드** : 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다. 시스템에 중요한 영향을 미치는 연산은 커널 모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지할 수 있다.


# 📌 구조
![](https://images.velog.io/images/kcwthing1210/post/4426b26e-192c-4b3e-8581-7396a42b67c0/image.png)
커널모드와 유저모드의 구조는 위와 같다. 사용자가 직접적으로 하드웨어 장치를 제어한다면 큰 문제 발생할 수 있기 때문에 사용자 애플리케이션은 System Call 을 통해 직접적인 하드웨어 요청이나 중요한 시스템 요청을 한다.



커널 모드와 사용자 모드를 구분하기 위해 하드웨어 적으로 CPU 내부에 모드 비트(mode bit)를 사용한다. 모드 비트가 0으로 세팅되어 있으면 커널 모드로서 모든 명령을 수행할 수 있고, 모드 비트가 1로 세팅되어 있으면 사용자 모드로서 제한된 명령만을 수행할 수 있다.



그렇기 때문에 CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드 비트는 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행하게 된다.

![](https://images.velog.io/images/kcwthing1210/post/f3352cc3-dc76-4a55-aae3-80da9d6837ab/image.png)

프로세스는 두 모드중 하나의 모드만을 가지는 것이 아니라 실행되는 동안 수없이 유저모드와 커널모드를 반복하면서 실행된다.



예를 들어 프로세스가 사용자 모드에서 작업을 수행하다 하드웨어 접근 등 보안에 필요한 중요한 명령을 수행해야 할 경우에는 시스템 콜(소프트웨어 인터럽트)을 통해 운영체제에게 서비스를 대신해 줄 것을 요청하게 된다. 그러면 CPU의 제어권은 다시 운영체제로 넘어가게 된다. 인터럽트가 발생할 때에는 모드 비트가 자동적으로 0으로 세팅되어 필요한 작업을 수행하고 요청된 작업이 끝나게 되면 모드 비트는 다시 1로 만들어 사용자 프로그램에게 CPU를 넘겨주게 된다.


# 📌 특징


## ✔ 유저모드

- 사용자 애플리케이션의 코드가 실행 됨.
- 시스템 데이터에 제한된 접근만이 허용, 하드웨어 직접 접근 불가.
- 시스템 서비스 호출 시 유저모드에서 커널모드로 잠시 전환됨.
- 스레드는 자신만의 유저모드 스택을 가짐.



## ✔ 커널모드

- 모든 시스템 메모리에 접근할 수 있고 모든 CPU명령 실행 가능.
- 운영체제 코드나 디바이스 드라이버 같은 커널모드 코드를 실행한다.




# 🧩 Reference
- https://kosaf04pyh.tistory.com/196
- https://phaphaya.tistory.com/30 [pAPaYA]

# 🎁 인터럽트
# 📌 정의
CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.
인터럽트는 크게 내부 인터럽트와 외부 인터럽트로 나뉜다.

# 📌 종류
## ✔ 내부 인터럽트
- 하드웨어 고장(Hardware Interrupt)
    - 컴퓨터 고장
    - 데이터 전달 과정에서의 비트 오류
    - 전원이 나간 경우
- 실행할 수 없는 명령어 : 기억장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우
- 명령어 실행 오류 : 나누기 0을 하는 경우
- 사용 권한 위배 : 사용자가 운영체제만 사용할 수 있는 자원에 액세스하는 경우
## ✔ 외부 인터럽트
외부 인터럽트는 주로 입출력장치 에 의해 발생된다.

- 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 중앙처리장치에게 인터럽트를 요청
- 입출력 인터럽트 : 속도가 느린 입출력장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트를 요청

# 📌 처리과정
![](https://images.velog.io/images/kcwthing1210/post/0dda40dc-3285-4d44-a41e-68b4e61fdcf6/image.png)

명령어 사이클은 인출(fetch stage)과 실행(execution stage) 두 가지 단계를 반복해서 수행한다. 그런데 인터럽트 요청이 들어왔다고 해서 바로 이를 처리하는 것이 아니라, 명령어 N의 실행 단계를 마쳐야 한다. 명령어의 실행단계를 마칠 때마다 중앙처리장치는 반복적으로 인터럽트 요청이 있는지 계속해서 확인한다. 인터럽트 요청이 있어야 인터럽트 서비스 단계를 진행한다.

좀 더 큰 개념으로 살펴본다면 아래와 같은 그림이 된다.

![](https://images.velog.io/images/kcwthing1210/post/0a91b17d-b50b-4150-a0ed-34d078816357/image.png)


# 📌 관련용어
- 인터럽트 핸들러
  실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 한다.
  운영체제의 코드 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그램되어 있다.

- 인터럽트 벡터
  인터럽드 발생시 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블이다.

# 🧩 Reference
- https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8
- https://whatisthenext.tistory.com/147

# 🎁 데드락
# 📌 데드락(Deadlock) 이란?
- 시스템 자원에 대한 요구가 뒤엉킨 상태

즉, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 일컫습니다.

# 📌 데드락의 발생조건
## ✔ 상호 배제
한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
## ✔ 점유 대기
자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
## ✔ 비선점
이미 할당된 자원을 강제로 빼앗을 수 없다(비선점).
## ✔ 순환 대기
대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

# 📌 데드락(Deadlock)의 해결법

## ✔ 데드락 예방(Prevention)
데드락의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것이 데드락을 예방하는 방법입니다. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

- 자원의 상호 배제 조건 방지 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
  그러나 추후 동기화 관련 문제가 발생할 수 있다.
- 점유 대기 조건 방지 : 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.

- 비선점 조건 방지 : 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
- 순환 대기 조건 방지 : 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.
  이러한 조건을 방지해서 데드락을 예방하는 방법은 시스템의 처리량이나 효율성을 떨어트리는 단점이 발생할 수 있다.

## ✔ 데드락 회피(Avoidance)
시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 안정 상태(safe state)에 있다고 말한다.

그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서를 찾을 수 있다면, 그것을 안전 순서(safe sequence)라고 부른다.

반면 불안정 상태는 안정 상태가 아닌 상황을 말합니다. 즉, 데드락 발생 가능성이 있는 상황이며, 교착 상태(데드락)는 불안정 상태일 때 발생할 수 있습니다. 불안정 상태가 교착 상태보다 좀 더 큰 집합입니다.(즉, 교착 상태가 불안정 상태의 부분집합)

이처럼 회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징이다.

이러한 특징을 살린 알고리즘의 예시로 은행원 알고리즘이 있다.



🔑 은행원 알고리즘(Banker’s Algorithm)
다익스트라가 제안한 기법으로, 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사합니다. 즉 대기중이 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것입니다.

어떤 자원 한 가지에 대해서 은행원 알고리즘을 시뮬레이션 해보고자 합니다.

처음에 시스템이 총 12개의 자원을 가지고 있다고 가정해 보겠습니다.

![](https://images.velog.io/images/kcwthing1210/post/bf75e1e6-5364-4071-9dd3-cab8d99c41c3/image.png)
- P0~P2 : 프로세스
- Max :  각 프로세스마다 최대 자원 요청량
- Allocation : 현재 프로세스에 할당 중인 자원의 양
- Need : 남은 필요한 자원의 양(Max-Allocation)

현재 t0일 때 프로세스에 할당된 자원의 합은 5+2+2=9개 이다. 따라서 현재 Available 자원은 12 - 9 = 3개 이다.

순서가 <P1, P0, P2> 일 때 안전 순서를 만족한다.

- P1은 2개가 이미 할당되어 있고, 2개를 추가적으로 할당받기를(Need) 기다리고 있다. 현재 Available 자원은 3개이므로, 이 중에 2개를 P1에게 할당해 준다 => 현재 Available은 3 - 2 = 1개
- 실행이 끝난 P1은 자신에게 할당되어 있던 자원 4개를 모두 반납한다 => 현재 Available은 1 + 4 = 5개

- 현재 Available 자원이 5개이고, 이를 P0에게 모두 할당해 주면 P0도 실행 가능해진다. => 현재 Available은 5 - 5 = 0개 가 됩니다.
- 실행이 끝난 P0은 자신에게 할당되어 있던 자원 10개를 모두 반납한다. => 현재 Available은 0 + 10 = 10개
- 마지막으로 P2에게 자원 7개를 할당해 준다. => 현재 Available은 10 - 7 = 3개
- 실행이 끝난 P2는 자신에게 할당되어 있던 자원 9개를 모두 반납한다. => 현재 Available은 3 + 9 = 12개
  이렇게 자원의 부족함 없이 올바르게 할당하여 모든 프로세스가 실행을 할 수 있었습니다.

❗ 만약 여기에서 P2 프로세스가 처음에 자원을 하나 더 할당받고 있었다면(즉, 2개가 아니라 3개) 운영체제가 가지고 있는 Available 자원은 12 - (5+2+3) = 2개 였을 것이다.

이 상황에서는 처음에 P1에게 2개를 모두 주고, P1이 실행이 끝나고 자원을 모두 반납해도 Available 자원은 2 + 2 = 4개 뿐이므로, 이 자원으로는 나머지 P0이나 P2 프로세스를 해결해 줄 수 없다. (모두 4개보다 많은 양의 자원을 필요로 하고 있으므로)

따라서 P0, P2는 자원을 할당받기를 계속 기다려야 할 것이다.

운영체제가 사전에 P2 프로세스가 자원을 하나 더 요청했을 때 할당해 주지 않고, P1이 먼저 끝나게 한다면 데드락이 발생하지 않았을 것이다. 은행원 알고리즘을 통해 이러한 부분이 해결 가능하다.

그러나 은행원 알고리즘의 경우, 이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재한다.


## ✔ 데드락 탐지(Detection) 및 회복(Recovery)
먼저 시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 데드락을 탐지하고, 회복하는 알고리즘을 사용한다.

- 탐지 기법
  Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.
  이 외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다.
- 회복 기법
    - 단순히 프로세스를 1개 이상 중단시키기
        -  교착 상태에 빠진 모든 프로세스를 중단 시키는 방법 : 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 겨로가가 폐기가 될 수 있는 부작용이 발생 할 수 있음
        - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법 : 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
    - 자원 선점하기
        - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법


# 🧩 Reference
- https://chanhuiseok.github.io/posts/cs-2/
