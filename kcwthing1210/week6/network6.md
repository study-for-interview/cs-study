# 🎁 Blocking,Non-blocking & Synchronous,Asynchronous
# 📌 정의
## ✅ 블로킹 Blocking
A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것
## ✅ 논블로킹 Non-blocking
A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것.
## ✅ 동기 Synchronous
A 함수가 B 함수를 호출 할 때, B 함수의 결과를 A 함수가 처리하는 것.
## ✅ 비동기 Asynchronous
A 함수가 B 함수를 호출 할 때, B 함수의 결과를 B 함수가 처리하는 것. (callback)



# 📌 모델
![](https://images.velog.io/images/kcwthing1210/post/6ea5389a-086f-4f19-a924-8d0973a2be71/image.png)

## ✅ Sync-Nonblocking 모델

![](https://images.velog.io/images/kcwthing1210/post/2ee037f7-66c7-4aa9-90c4-207f0bd8fec0/image.png)
B 함수가 바로 제어권을 돌려주기에 A 함수는 다른 작업을 수행할 수 있지만,
언제 종료되는지 알 수 없는 B 함수의 종료를 A 함수가 처리해야 한다.
A 함수가 직접 결과를 처리해야하는 상황이기에 B 함수의 종료를 반복적으로 물어봐야 하는 경우이다.

## ✅ Async-Blocking 모델
![](https://images.velog.io/images/kcwthing1210/post/8f5501ab-f99a-4391-92f4-b4d5b58749a8/image.png)
그림만 봐도 알 수 있듯 굉장히 비효율적으로 보이는 모델

# 🧩 Reference
- https://jh-7.tistory.com/25

# 🎁 Blocking & Non-Blocking I/O
일단 (blocking io, non-blocking io, sync, async)공통적으로 IO는 user-space aplication 에서 직접 수행 될 수 없고 IO를 수행하기 위해서는 결국 커널에 한번 이상 시스템 콜을 보내야한다. 시스템 콜을 보내게되면 그 순간에 커널로 제어권이 넘어가고(context-switch), 유저 프로세스(or 스레드)는 제어권이 다시 돌아 오기 전에는 block이 된다. 쉽게 말하자면 block 이 되어 있는 동안 유저프로세스는 다른 작업을 하지 못하게 된다.

# 📌 sync blocking IO
![](https://images.velog.io/images/kcwthing1210/post/28338c00-775d-4bd9-9d2e-b8887fce07e1/image.png)

- 시스템 콜이 들어오면, 커널은 IO 작업이 완료되기전에는 응답을 하지않는다.
- 즉 IO 작업이 완료되기전에는 제어권을 커널이 갖고있는다
- 그렇기에 시스템 콜을 보낸후에, 유저 프로세스는 응답을 받기 전에는 block이 되어 다른 작업을 하지못한다. 즉 IO 작업이 완료되기 전에는 다른 작업을 수행하지 못한다.

# 📌 sync non-blocking IO
![](https://images.velog.io/images/kcwthing1210/post/858090c2-c715-43f2-b6da-af7041f2e7f7/image.png)

- 시스템 콜이 들어오면, 커널은 IO 작업의 완료 여부와는 무관하게 즉시 응답을 해준다. (완료 되지않았다면 에러코드를 응답함.)
- 이는 커널이 시스템 콜을 받자마자 제어권을 다시 유저 프로세스에게 넘겨 준다는 것이기에, 유저 프로세스는 IO 가 완료 되기 전에도 다른 작업을 할수있는 것이다.
- 유저 프로세스는 다른 작업들을 수행하다가 중간 중간에 시스템 콜을 보내서 IO가 완료되었는지 커널에게 물어보게된다.

# 📌 async blocking IO
![](https://images.velog.io/images/kcwthing1210/post/e5f78b2c-b3bb-4542-a36c-85a75a8e65e7/image.png)

- 이 모델에서는 IO는 non-blocking이지만, 통지(notification)는 blocking 방식으로 하도록 되어있다.
- select() 는 유저 프로세스를 block 한다.
- select() 는 데이터가 사용이 가능해지면, 통지를 받게됨. 통지를 받으면 block을 품

# 📌 async non-blocking IO
![](https://images.velog.io/images/kcwthing1210/post/9832d237-b709-4e6c-93b8-16094092e2af/image.png)
- 시스템 콜이 들어오면, 커널은 IO 작업의 완료 여부와는 무관하게 즉시 응답을 해준다.
- 유저 프로세스는 IO 가 완료 되기 전에도 다른 작업을 할수있는 것이다.
- IO 처리는 백그라운드에서 실행되다가, 완료되면 커널이 유저 프로세스에게 알려줌.
    - 이는 sync non-blocking IO와의 차별점이라고 볼수있다.
    - sync nonblocking IO는 유저 프로세스가 IO 완료 여부를 커널에게 계속 물어봐야 했지만,
    - async non-blocking IO는 IO 완료가 되면 그때 커널이 유저프로세스에게 알려주는 방식이므로

  # 🧩 Reference
    - https://limdongjin.github.io/concepts/blocking-non-blocking-io.html#ibm-%E1%84%8B%E1%85%A1%E1%84%90%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF
    

# 🎁 웹 통신의 큰 흐름
# 📌 웹 통신의 큰 흐름
## ✅ 브라우저
![](https://images.velog.io/images/kcwthing1210/post/10c97eb8-98d5-4234-b325-018c05f939e3/image.png)
- 우리가 위처럼처럼 네이버를 검색하게 되면 브라우저는 일단 해당 URL의 구조를 분석합니다.
  ![](https://images.velog.io/images/kcwthing1210/post/0b117ce1-ba59-4750-82bb-ffb363ca33ec/image.png)

- 분석한 의미에 따라 Http request 메시지를 만든다.
- 브라우저는 os를 통해 url을 IP로 변경하게 되는데 과정은 아래와 같다.
    - 자신의 로컬 hosts 파일과 브라우저 캐시에 해당 URL이 존재하는지 확인.
    - 존재하지 않는다면 해당 url을 DNS를 통해 컴퓨터가 읽을 수 있는 IP로 변경.


※ 브라우저 캐시: 해당 사이트를 다시 접속할때 로딩 속도를 높여주기 위해 캐시로 남김

## ✅ 프로토콜 스택, LAN 어댑터

- 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다.
- 브라우저로부터 받은 메시지를 패킷 속에 저장한다.
- 수신처 주소 등의 제어정보(트래픽, 경로)를 덧붙인다.
- 패킷을 LAN 어댑터에 넘긴다.
- LAN 어댑터는 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환시킨다.
- 신호를 LAN 케이블에 송출시킨다.

※ Hop: 컴퓨터 네트워크에서 출발지와 목적지 사이에 위치한 경로의 한 부분

## ✅ 허브, 스위치, 라우터
- LAN 어댑터가 송신한 프레임은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.
- 라우터는 패킷을 프로바이더(통신사)에게 전달한다.
- 인터넷으로 접속하게 된다.

## ✅ 액세스 회선, 프로바이더
- 패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반된다.
- POP 를 거쳐 인터넷의 핵심부로 들어가게 된다.
- 수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러가게 된다.
  ![](https://images.velog.io/images/kcwthing1210/post/be6a294e-4c24-41c9-a0f8-441abbb0eff4/image.png)

## ✅ 방화벽, 캐시서버
- 패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN 에 도착.
- 기다리고 있던 방화벽이 도착한 패킷을 검사.
- 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시서버가 존재한다.
  ![](https://images.velog.io/images/kcwthing1210/post/225304a3-8072-4d76-9e19-ff7de4c286b9/image.png)

## ✅ 웹 서버
- 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 WAS에 넘긴다.
- 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.
- 왔던 방식대로 응답 메시지가 클라이언트에게 전달된다.
  ![](https://images.velog.io/images/kcwthing1210/post/15f5b264-d038-495c-9ae7-b33845cfc8e1/image.png)

# 🧩 Reference
- https://codediary21.tistory.com/82#:~:text=%ED%8C%A8%ED%82%B7%EC%9D%B4%20%EB%AC%BC%EB%A6%AC%EC%A0%81%EC%9D%B8%20%EC%9B%B9,%EA%B0%80%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EA%B2%8C%20%EC%A0%84%EB%8B%AC%EB%90%9C%EB%8B%A4.

# 🎁 DNS Round Robin
📌 DNS
✅ DNS란?
www.xxxx.com 과 같이 사람이 읽을 수 있는 이름을 192.0.0.1과 같은 숫자 IP주소로 변환하여 컴퓨터가 서로 통신 할 수 있도록 도와주는 서버이다.
DNS 시스템은 이름을 숫자로 매핑하여 마치 전화번호부와 같은 기능을 한다.
DNS 서버는 이름에 대한 요청을 IP주소로 변환하여 최종 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할 것인지는 제어한다. 이 요청을 쿼리 라고 한다.
✅ Domain 구조


도메인은 전 셰계적으로 고유하게 존재하는 이름이다.
정해진 규칙에 따라야 하며 임의로 변경,생성할 수 없다.
모든 도메인은 "." (닷) 또는 루트라 불리는 도메인 아래에 그림과 같이 역트리 구조로 계층적으로 구성되어 있다.
루트 아래 단계를 최상위 도메인(TLD: Top Level Domain)이라고 부르며, 그 다음 단계는 도메인(SLD : Second Level Domain) 이라고 한다.
일반 최상위 도메인과 국가 최상위도메인으로 구분하며 일반 최상위 도메인은 스폰서 도메인과 언스폰서 도메인으로 구분된다.
✅ DNS 동작원리


사용자가 www.naver.com 을 브라우저에 입력한다.
Local DNS에게 IP 주소를 질의하여 캐시된 것에 없으면 다른 DNS 서버에 전달 (Root DNS)
ROOT 로 부터 com 도메인을 관리하는 TLD이름 서버 정보 전달 받는다.
COM DNS로 질의 한다.
naver.com DNS 정보를 전달 받는다.
www.naver.com 호스트네임에 대한 IP 주소를 질의 한다.
IP 정보를 전달받는다.
Local DNS는 www.nvaer.com에 대한 IP 주소를 캐싱을 하고 IP 주소 정보를 전달한다.
※ ROOT -> COM -> xxx.com 서버를 차례대로 질의해서 답을 찾는 과정을 Recursive Query라고 한다.

📌 DNS ROUND ROBIN
별도의 SW,HW로드벨런싱 장비 없이 오직 DNS만을 이용하여 도메인 레코드 정보를 조회하는 시점에서 트래픽을 분산하는 기법이다.
웹 뿐만 아니라, 도메인을 사용하는 모든 서비스(FTP,SMTP 등)에 사용이 가능하다.


✅ 라운드 로빈 원리
웹 서비스를 담당할 여러 대의 웹 서버는 자신의 공인 IP를 각각 가지고 있다.
사이트 접속을 위해 사용자가 해당 도메인 주소를 브라우저에 입력하면 DNS는 도메인의 정보를 조회하는데 이떄 IP주소를 여러 대의 서버 IP리스트 중에서 라운드 로빈 형태로 랜덤하게 하나 혹은 여러개를 선택하여 사용자에게 알려준다.
결과적으로 웹 사이트에 접속하는 다수의 사용자는 실제로는 복수의 웹 서버에 나뉘어 접속하도 되면서 자연스럽게 서버의 부하가 분산되는 방식이다.
라운드 로빈 DNS는 여러개의 IP주소를 결과로 돌려준다.

사용자의 OS 애플리케이션에 따라 동작이 다르다.
여러개의 IP 중 제일먼저 조회된 IP를 선택, 무작위로 IP를 선택한다.
또는 선택 IP 접속이 안되면 그다음 조회된 IP접속하도록 호직을 추가할 수 있다.

✅ 단점
지리적으로 복수의 웹서버가 멀리 떨어져 있어 실시간 헬스 체크가 어렵다.
서버가 문제가 생겨 서비스가 불가한 상태라도 DNS는 이를 인지 못하고 도메인 조회 결과에 포함시킨다.
그래서 HA(High- Abaliability)용도로 적합하지 못한다.
DNS 조회 정보의 캐싱
모바일 사이트 등에서 문제가 발생한다.
스마트폰의 접속은 캐리어 게이트웨이 라고 하는 프록시 서버를 경유한다.
프록시 서버에서는 이름변환 결과가 일정 시간 동안 캐싱되므로 같은 프록시 서버를 경유 하는 접속은 항상 같은 서버로 접속된다.
PC용 웹 브라우저도 DNS 질의 결과를 캐싱하기 때문에 균등하게 부하 분산되지 않는다.
DNS 레코드의 Time To Live(TTL)값을 짧게 설정함으로써 어느 정도 해소가 되지만 TTL에 따라 캐시를 해제하는 것은 아니므로 반드시 주의가 필요하다.
웹 페이지, 스트림 된 영상, 데이터베이스 쿼리 결과만 캐싱 하는 것이 아닌, DNS가 조회한 도메인의 IP 정보도 네트워크 상에서 캐싱한다는 것❗❗
도메인 설정 작업을 할때에는 캐싱 주기 설정을 고민해야 한다.
캐싱을 무조건 길게 하면 관리자가 급하게 DNS 정보를 바꿔도 인터넷상에서 적용되려면 해당 시간 이상으로 기다려야 한다.
바뀐 DNS 정보가 인터넷상의 네임 서버에 전파 되는 데 오랜 시간이 걸리기 때문이다.
반배로 캐싱 주기를 짧게 하면 빠른 업데이트 반영은 가능하지만, 도메인 조회가빈번해지면서 사용자가 웹 사이트에 접속하는데 필요한 시간이 증가한다.
라운드 로빈 DNS는 가용성을 제공하지 않기 때문에, 무중단 서비스가 필요한 시스템에는 어울리지 않는다.

단순히 여러 대의 웹 서버로 트래픽을 부하 분산할 때 가장 편리하게 사용할 수 있는 옵션이다.

가용성이 필요한 시스템의 경우, Health Check기능이 포함된 DNS 서비스를 사용하는 것이 좋다.

AWS Route53, Dyn DNS 서비스가 좋은 예다.

✅ 라운드 로빈 DNS 단점 보완
GSLB(Global Server Load Balancing) DNS 서비스를 사용하여 도메인 조회 시, 로드 밸런싱과 동시에 Health check 기능을 사용한 HA구성이 모두 가능하도록 구성하는 것 또한 안전한 방법이다.
로드벨런서 또한 SPOF(Single Point Of Faliure)가 될 수 있으므로, 2 대 이상의 로드밸런서와 각각의 공인 IP를 준비하고, GSLB로 트래픽을 로드밸런서에 나누는 방법도 많이 사용한다.
로그인 세션 등 세션의 유지 서버-클라이언트 간에 필요한 경우, 접속 중이던 클라이언트가 DNS에 의해 다른 서버IP를 할당받아 다른 서버에 접속이 되면 기존 세션이 끊어질 수 있다.
이런 경우 웹 서버끼리 세션을 공유할 수 있도록 세션 클러스터링 설정을 하거나, 로드 밸런서에서 IP나 Cookie 값을 사용하여 동일한 서버로 접속되도록 stickness 설정을 해야 하는데, 이 부분은 L7 스위치로 해결할 수 있다.
✅ 라운드 로빈 상식 기반 단점을 해소하는 DNS 스케줄링 알고리즘(일부)
✔ Weighted round robin (WRR)
각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다. 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버는 가중치를 높게 설정하는 것이 좋다.

✔ Least connection
접속 클라이언트 수가 가장 적은 서버를 선택한다. 로드밸런서에서 실시간으로 connection 수를 관리하거나 각 서버에서 주기적으로 알려주는 것이 필요하다.

🧩 Reference
https://byeongyeon.tistory.com/80