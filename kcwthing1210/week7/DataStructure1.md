# 🎁 배열
# 📌 배열
## ✅ Array(배열)의 형태
- 메모리 상에 데이터(원소)를 연속하게 배치한 자료구조 이다.
- 배열의 종류에는 직선형(1차원 배열), 직사각형형(2차원 배열), 직육면체형(3차원 배열) 등이 있다.

![](https://images.velog.io/images/kcwthing1210/post/a0e79c31-131b-4ac3-b094-8b77aa616509/image.png)

## ✅ Array(배열)의 특징
- 추가적으로 소모되는 메모리 양(=overhead)이 거의 없다.
- Cache hit rate가 높다.
- 배열을 생성하려면 메모리 상에 연속한 구간을 할당해야 해서 할당에 제약이 걸릴 수 있다.

## ✅ Array(배열)에서 사용할 수 있는 연산들과 시간복잡도
#### ✔ 임의의 위치에 있는 원소를 확인하거나 변경하는 연산 : O(1)의 시간이 걸림

메모리 상에 일렬로 나열되어 있으니 배열의 시작 주소에서 k칸 만큼 더하면 k번째 원소를 찾을 수 있다.

k번째 원소의 위치 = 시작주소 + (1칸이 차지하는 주소 X k)

이므로 단순 사칙연산 계산에 의해 O(1)만에 k번째 원소를 찾을 수 있다.

k번째 원소 위치를 찾았다면 원소를 확인하거나 변경해주면 된다.
![](https://images.velog.io/images/kcwthing1210/post/51e0f655-3f85-4ab0-92ec-5dc19f051458/image.png)

#### ✔ 배열의 가장 끝에 원소 추가하기 : O(1)의 시간이 걸림

배열의 끝 주소 = 시작 주소 + (1칸이 차지하는 주소 X 배열 길이)

위 수식을 통해 배열의 끝 주소를 찾고, 배열의 길이를 1 증가시킨 후, 추가할 원소 데이터를 저장하면 된다.

이것도 시간복잡도는 O(1)이다.

![](https://images.velog.io/images/kcwthing1210/post/752d3987-82ab-4e93-aaef-b27e8126d746/image.png)

#### ✔ 배열의 가장 끝 원소 삭제하기 : O(1)의 시간이 걸림

위에서 알아본 배열의 가장 끝에 원소 추가하기와 비슷하게 배열의 끝 주소를 찾고, 배열의 길이를 1만큼 줄이면 되므로 시간복잡도는 O(1)이다.

![](https://images.velog.io/images/kcwthing1210/post/fcbe6618-8a9f-4ebc-a4da-15fe7d3174a2/image.png)

#### ✔ 임의의 위치에 원소를 추가하기 : O(N)의 시간이 걸림

임의의 위치에 원소를 새로 추가해서 끼워넣으려면 그 뒤에 존재하는 모든 원소들을 한 칸씩 뒤로 밀어야 한다.

![](https://images.velog.io/images/kcwthing1210/post/2c6a8b33-cc73-49aa-b353-91f49138efca/image.png)

뒤로 미는 연산이 한 번 일어날 때 O(1)이 걸린다. 만약 N개의 원소를 한 칸씩 밀어야 한다면 O(1XN) = O(N)이 걸리게 된다.

추가하려는 위치가 배열의 끝과 가까울수록 그 뒤에 존재하는 원소의 개수가 적어져 뒤로 밀어내는 연산의 수도 줄어든다.

추가하려는 위치가 배열의 처음과 가까울수록 그 뒤에 존재하는 원소의 개수가 많아져 뒤로 밀어내는 연산의 수도 늘어난다.

하지만 평균으로 계산해보면 N/2 개의 원소를 뒤로 밀어내야 하므로 시간복잡도는 O(N/2) = O(N)이 걸린다.

#### ✔ 임의의 위치에 있는 원소를 제거하기 : O(N)의 시간이 걸림

이 연산도 임의의 위치에 원소를 추가하는 것과 비슷하게 수행된다.

임의의 위치에 있는 원소를 삭제하면 그 뒤에 존재하는 모든 원소들을 한 칸씩 앞으로 당겨와야 한다.

왜 굳이 앞으로 당겨와야 할까?

배열의 정의 상 배열은 메모리 상에 데이터(원소)를 연속하게 배치한 자료구조이기 때문이다.

![](https://images.velog.io/images/kcwthing1210/post/f576255d-471a-4165-91e8-143ef41077e1/image.png)

앞으로 당기는 연산이 한 번 일어날 때 O(1)이 걸린다. 만약 N개의 원소를 한 칸씩 앞으로 당겨야 한다면 O(1XN) = O(N)이 걸리게 된다.

제거하려는 원소의 위치가 배열의 끝과 가까울수록 그 뒤에 존재하는 원소의 개수가 적어져 앞으로 당기는 연산의 수도 줄어든다.

제거하려는 위치가 배열의 처음과 가까울수록 그 뒤에 존재하는 원소의 개수가 많아져 앞으로 당기는 연산의 수도 늘어난다.

하지만 평균으로 계산해보면 N/2 개의 원소를 앞으로 당겨야 하므로 시간복잡도는 O(N/2) = O(N)이 걸린다.

## ✅ Array(배열)의 장/단점
### ✔ 장점

- Index를 통해 원소에 O(1) 시간복잡도 만에 빠르게 접근할 수 있다.

### ✔ 단점

- 새로운 원소를 삽입하고 삭제하는데 O(N) 시간복잡도가 걸려 느리다.

- 연속된 메모리 상에 원소들이 존재하므로 처음 배열을 선언한 크기만큼 데이터를 저장하지 않는다면 메모리 낭비가 발생한다.
    - 예를 들어, 배열 선언시 배열의 크기를 10으로 선언했는데 3개의 원소에만 데이터를 저장했을 경우 7개의 원소는 비어있게 되므로 7개 원소가 차지하는 메모리 공간만큼 낭비가 발생하게 된다.

#### ✔ 배열을 언제 사용해야 좋을까?

- 데이터 개수가 확실하게 정해져 있을 때 데이터 저장을 위한 자료구조로 선택하면 좋다.

- 또한, 삽입/삭제 작업이 적을 때 사용하면 좋다.

- 마지막으로 배열에 저장된 데이터를 검색하는 작업이 많을 때 사용하면 좋다.(인덱스로 빠르게 검색 가능)


# 🧩 Reference
- https://choheeis.github.io/newblog//articles/2020-12/data-structure-array

# 🎁 List

# 📌 리스트(Linked List)

## ✅ Linked List(연결 리스트)의 형태
- Linked List(연결 리스트) 는 배열과 다르게 데이터를 메모리 상의 이곳 저곳에 연속되지 않게 저장한다. 이 때, 각 원소는 다음 원소의 메모리 주소를 함께 저장하고 있다.

![](https://images.velog.io/images/kcwthing1210/post/6f255095-f927-44a5-befe-02ddc0f53704/image.png)

- Linked List(연결 리스트)의 맨 첫 번째 원소의 위치만 알고 있어도 나머지 원소들의 위치는 각 원소에 저장되어 있으므로 결국 모든 원소의 위치를 알 수 있게 되는 것이다.

- 따라서 Linked List(연결 리스트)는 메모리 상에 데이터가 연속적이지는 않지만 각 원소가 어디에 위치해 있는지 알 수 있다.

- Linked List(연결 리스트)의 종류에는 단방향 연결 리스트(Singly Linked List), 이중 연결 리스트(Doubly Linked List), 원형 연결 리스트(Circular Linked List) 가 있다.


## ✅ Linked List(연결 리스트)의 특징
- 원소들이 메모리 상에 연속되어 있지 않아 Cache hit rate가 낮지만 할당이 다소 쉽다.

## ✅ Linked List(연결 리스트)에서 사용할 수 있는 연산들

#### ✔ 임의의 위치에 있는 원소를 확인하거나 변경하는 연산 : O(N)의 시간이 걸림

![](https://images.velog.io/images/kcwthing1210/post/aefb46ba-ba44-46ef-a518-bae2f68e0498/image.png)

만약 위 그림에서 20을 저장하고 있는 원소를 확인하고 싶다면 20을 저장하는 원소의 위치를 알아야 할 것이다.

이 위치를 어떻게 알 수 있을까?

가장 먼저 첫 번째 원소인 10을 저장하고 있는 원소를 방문해서 다음 원소인 5가 존재하는 위치를 확인해야 한다.(연결 리스트를 사용할 때는 가장 첫 번째 원소의 위치만 알고 있게 된다.)

확인 후, 5를 저장하는 원소를 찾아가 방문한다.

5를 저장하는 원소를 통해 4를 저장하는 원소의 위치를 알게 되고, 4를 저장하는 원소를 찾아가 방문한다.

4를 저장하는 원소를 통해 비로소 20을 저장하는 원소의 위치를 알게 되어 20에 찾아갈 수 있다.

하지만 Linked List(연결 리스트)는 배열과 다르게 k번째 원소의 위치를 알아내기 위해서는 원소를 타고 타고 방문해야 k번째 원소의 위치를 알 수 있기 때문에 O(k)의 시간이 걸린다.

이 과정을 통해 k번째 원소가 있는 위치에 도착했다면 해당 원소의 data를 확인하거나 변경하면 된다.

#### ✔ 임의의 위치에 원소를 추가하는 연산 : O(1)의 시간이 걸림

임의의 위치에 원소를 추가하려면 추가할 원소를 메모리의 어느 위치에 저장한 후, 이전 원소가 가지고 있던 다음 원소 주소를 방금 추가한 원소의 위치로 바꿔주면 된다.

![](https://images.velog.io/images/kcwthing1210/post/8e1555e2-ecca-4274-914f-08621fd76eb0/image.png)

위 그림처럼 기존에 저장하고 있던 다음 원소 위치를 새로 추가한 원소의 위치로 업데이트 해주기만 하면 되므로 O(1)의 시간이 걸린다.

단, O(1)이 시간이 걸린다는 것은 O(N)에 걸려 추가할 원소의 바로 이전 원소까지 방문된 상태에서 이 원소의 주소 값만 없데이트 하는데 O(1)이 걸린다는 것이다.

따라서 Linked List에 사용되는 함수 중 add(임의의 위치) 함수는 결과적으로 O(N)이 걸릴 것이다.

#### ✔ 임의의 위치에 있는 원소를 제거하는 연산 : O(1)의 시간이 걸림

임의의 위치에 있는 원소를 제거하려면 원소를 제거한 후, 이전 원소가 가지고 있던 다음 원소 주소를 제거한 원소의 다음 원소 주소로 업데이트 해주면 된다.

![](https://images.velog.io/images/kcwthing1210/post/bbf3f00d-2702-4317-9029-74a5b2366433/image.png)

위 그림처럼 기존에 저장하고 있던 다음 원소 위치를 제거한 원소의 다음 원소 위치로 업데이트 해주기만 하면 되므로 O(1)의 시간이 걸린다.

단, O(1)이 시간이 걸린다는 것은 O(N)에 걸려 제거할 원소의 바로 이전 원소까지 방문된 상태에서 이 원소의 주소 값만 없데이트 하는데 O(1)이 걸린다는 것이다.

따라서 Linked List에 사용되는 함수 중 remove(임의의 위치) 함수는 결과적으로 O(N)이 걸릴 것이다.

## ✅ Linked List(연결 리스트)의 종류
### ✔ 단일 연결 리스트(Singly Linked List)

단일 연결 리스트는 각 원소가 자신의 다음 원소의 주소를 저장하고 있는 연결 리스트 이다.

![](https://images.velog.io/images/kcwthing1210/post/7f76320e-0ab9-44fd-94b8-203aa2cedf94/image.png)

#### ✔ 이중 연결 리스트(Doubly Linked List)

이중 연결 리스트는 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 저장하고 있는 연결 리스트 이다.

https://user-images.githubusercontent.com/31889335/101610931-379e9f80-3a4c-11eb-9232-5f6f460c32ba.png

단일 연결 리스트에서는 각 원소의 다음 위치만 알아낼 수 있지만 이중 연결 리스트를 사용하면 각 원소의 이전 위치까지 알아낼 수 있다.

하지만 각 원소각 이전 위치까지 저장해야 하므로 메모리를 단일 연결 리스트보다 더 사용한다는 단점이 있다.

### ✔ 원형 연결 리스트(Circular Linked List)

원형 연결 리스트는 가장 마지막 원소가 맨 처음 원소의 주소를 저장하고 있는 연결 리스트 이다.

즉, 맨 끝과 맨 처음이 연결되어 있는 형태이다.

![](https://images.velog.io/images/kcwthing1210/post/d7512a06-3534-410e-8a43-ee4233dcfcd9/image.png)

## ✅ Array(배열)과 Linked List(연결 리스트)의 공통점과 차이점
### ✔ 공통점

배열과 연결 리스트는 원소들이 메모리 상에 저장되는 형태가 다르지만 어쨌든 둘 다 원소들 간의 선후 관계가 일대일로 명확한 자료구조이다.

즉, 원소들 사이에서 첫 번째 원소, 두 번째 원소, … 등의 개념이 존재한다는 것이다.

이러한 자료구조를 선형 자료구조 라고 부르고 배열과 연결 리스트는 둘 다 선형 자료구조이다.

### ✔ 차이점

- 임의의 원소(k번째 원소)에 접근하여 데이터 확인 및 변경하는데 걸리는 시간복잡도
    - 배열 : O(1)
    - 연결 리스트 : O(k)

- 임의의 위치에 원소를 추가하거나 임의의 위치에 있는 원소를 제거하는데 걸리는 시간복잡도
    - 배열 : O(k)
    - 연결 리스트 : O(1)

- 메모리 상의 배치
    - 배열 : 연속적으로 배치
    - 연결 리스트 : 비연속적으로 배치

- 추가 메모리 필요성
    - 배열 : 추가 메모리 없음
    - 연결 리스트 : 이전/다음 원소의 위치 주소를 저장할 추가 메모리가 N(원소의 개수)에 비례한 만큼 필요함

- 언제 사용할까?
    - 배열 : 배열에 저장된 원소를 빠르게 찾아야 하는 경우
    - 연결 리스트 : 중간 중간에 원소를 새로 추가하거나 제거해야 하는 작업이 많은 경우
      ex ) 주로 메모장같은 에디터 프로그램에서 많이 사용된다. 사용자가 입력한 문자열은 언제든지 사용자가 커서를 옮겨 문자를 삭제하거나 추가할 수 있도록 해야하기 때문이다.

## ✅ Linked List(연결 리스트)의 장단점
### ✔ 장점

- 새로운 원소를 삽입/삭제하는데 시간이 빠르다.

- 연속적인 메모리 할당이 필요하지 않다.

### ✔ 단점

- 임의의 위치에 있는 원소를 확인하려면 첫 번째 원소부터 확인해야 하기 때문에 속도가 느리다.

- 이전 노드 및 다음 노드의 위치를 저장하기 위한 추가 메모리 공간이 필요하다.

#### ✔ 연결 리스트를 언제 사용해야 좋을까?

- 삽입과 삭제 작업이 많을 때 사용하면 좋다.

- 연결 리스트에 저장된 원소를 검색하는 작업이 적을 때 사용하면 좋다.

# 🧩 Reference
- https://choheeis.github.io/newblog//articles/2020-12/data-structure-linked-list

# 🎁 HashTable


## ✅ HashTable(해시테이블)이란?
- 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다.
- 해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이다.
- 해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.

![](https://images.velog.io/images/kcwthing1210/post/b7fd5de0-7741-4714-a482-ba40279ca4d9/image.png)

예를 들어 우리가 (Key, Value)가 ("John Smith", "521-1234")인 데이터를 크기가 16인 해시 테이블에 저장한다고 하자. 그러면 먼저 index = hash_function("John Smith") % 16 연산을 통해 index 값을 계산한다. 그리고 array[index] = "521-1234" 로 전화번호를 저장하게 된다.

이러한 해싱 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회할 수 있다. 해시테이블의 평균 시간복잡도는 O(1)이다.

## ✅ Hash 함수(해시 함수)
해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 해시 테이블에 사용되는 대표적인 해시 함수로는 아래의 3가지가 있다.

- Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.( 주소 = 입력값 % 테이블의 크기) 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.
- Digit Folding: 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.
- Multiplication Method: 숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다. h(k)=(kAmod1) × m
- Univeral Hashing: 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.


## ✅ 해시(Hash)값이 충돌하는 경우
그런데 만약 "John Smith"를 해시 함수를 돌려 나온 값과 "Mang Kyu"를 해시 함수를 돌려 나온 값이 동일하다면 어떻게 해야 할까?

해시 테이블에서는 충돌에 의한 문제를 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing) 크게 2가지로 해결하고 있다.

### ✔ 분리 연결법
![](https://images.velog.io/images/kcwthing1210/post/19c299f6-febe-425d-b856-67ea8757b947/image.png)

Separate Chaining이란 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다. 위의 그림과 같이 동일한 버킷으로 접근을 한다면 데이터들을 연결을 해서 관리해주고 있다. 실제로 Java8의 Hash테이블은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaining 방식을 구현하였다.

이러한 Chaining 방식은 해시 테이블의 확장이 필요없고 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다. 하지만 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.

### ✔ 개방 주소법(Open Addressing)
Open Addressing이란 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다. Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

- Linear Probing: 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
- Quadratic Probing: 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
- Double Hashing Probing: 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

![](https://images.velog.io/images/kcwthing1210/post/5f52deaa-122b-4883-ab58-be922e7c0815/image.png)

Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 Hash Table을 재정리 해주는 작업이 필요하다고 한다.

## ✅ 해시테이블(HashTable) 시간복잡도

각각의 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간복잡도로 데이터를 조회할 수 있다. 하지만 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.

충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 공간을 많이 사용한다는 치명적인 단점이 있다.

만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확정을 하지 않도록 테이블을 설계해주어야 한다.

(통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

## ✅ Java의 HashMap(해시맵)과 HashTable(해시테이블) 차이

Java 개발자라면 (Key,Value)로 저장하는 익숙한 자료구조인 HashMap이 있다. 그렇다면 Java에서 HashTable과 HashMap의 차이가 당연히 있을 텐데, 그 차이는 동기화 지원 여부에 있다.

# 🧩 Reference
- https://mangkyu.tistory.com/102 [MangKyu's Diary]