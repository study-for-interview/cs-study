# 🎁 이진탐색
# ✅ 이진탐색이란?
- 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘

- 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값을 비교하는 방식

- 선택한 중앙 값을 기준으로 찾고자하는 값보다 크다면 기준의 왼쪽 범위에서, 찾고자하는 값보다 작다면 기준의 오른쪽 범위에서 다시 중앙 값을 선택하여 반복한다.

-  한번 비교를 거칠때 탐색 범위가 반(1/2)으로 줄어든다.

# ✅ 동작방식
![](https://images.velog.io/images/kcwthing1210/post/a55f8e59-0b21-4fcf-b311-14e682b77be1/image.png)

1. 위의 데이터 집합에서 8이란 데이터를 탐색하도록 가정한다. 첫번째 과정으로는 데이터 집합의 중앙 요소를 선택한다.
   ![](https://images.velog.io/images/kcwthing1210/post/7cb9c94b-75de-46a6-baef-f4e0da3720ea/image.png)

2. 두번째 과정으로는 중앙 요소의 값과 찾으려는 값을 서로 비교하게 되는데, 만약 찾으려는 값이 중앙 요소의 값보다 작다면 중앙 요소의 왼편에서 중앙 요소를 다시 택하고, 반대로 찾으려는 값이 중앙 요소의 값보다 크다면 오른편에서 중앙 요소를 다시 선택

그리고 다시 이진 탐색(Binary Search)를 거치는 것입니다. 위의 경우에는 찾으려는 값인 8이 중앙값 7보다 크므로 중앙값 왼편에 있는 데이터와 비교할 필요가 없으므로 중앙 요소 오른편에서 중앙값을 다시 택한다.

![](https://images.velog.io/images/kcwthing1210/post/27a194a4-8235-4e7d-9c5d-c2fd603e8074/image.png)

3. 이제는 중앙값이 9이고, 다시 중앙값과 찾으려는 값을 다시 비교하게 됩니다. 찾으려는 값 8은 중앙값 9보다 작으므로 중앙값 왼편에서 데이터를 찾아야 한다. 그럼 다시 왼편에서 중앙값을 선택하고 남은 데이터 8이 중앙값으로 택해지게 되는데 찾으려는 데이터와 일치하므로 탐색을 끝마친다.


![](https://images.velog.io/images/kcwthing1210/post/a752c5cf-9b41-4c3f-a520-8b8d6ac42e9e/image.png)

# ✅ 이진 탐색(Binary Search)의 성능

- 한번 비교가 이루어질때마다, 범위는 1/2로 줄어든다

- 위의 데이터 집합의 크기를 n으로 두고, 반복 횟수를 k로 둔다면 아래와 같은 수식이 만들어진다.
  ![](https://images.velog.io/images/kcwthing1210/post/fbb40a75-6a23-4e17-b6b3-d8025f6f078c/image.png)
  

# 🎁 동적계획법
# 📌 동적계획법
- DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)은 기본적인 아이디어로 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.

##  DP를 사용하는 이유
- 사실 일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사하다. 큰 차이점은 일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산될 수 있다는 것이다.

- ex) 피보나치 수열
    - 재귀로 계산 : return f(n) = f(n-1) + f(n-2)
    - f(n-1)에서 한 번 구한 값을 f(n-2)에서 또 다시 같은 값을 구하는 과정을 반복하게 되기 때문이다. 아래의 그림처럼 반복되는 계산을 또 하게 된다.

![](https://images.velog.io/images/kcwthing1210/post/15e22a25-1488-4006-87ec-7f9aca563c98/image.png)
- DP 에서는 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용


# 📌 DP의 사용 조건



### ✔  Overlapping Subproblems(겹치는 부분 문제)

- DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다.

- 즉, DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 해당 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.

- ex) 피보나치 수열에서  f(3), f(2), f(1)과 같이 동일한 부분 문제가 중복되어 나타난다. 그러므로 우리는 1회 계산했을 때, 저장된 값을 재활용할 수 있게 되는 것이다.
  ![](https://images.velog.io/images/kcwthing1210/post/109dc9d4-16f3-4380-94cd-cac066fb9f38/image.png)

### ✔ Optimal Substructure(최적 부분 구조)

- 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미한다. 그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다!

- 만약, A - B까지의 가장 짧은 경로를 찾고자 하는 경우를 예시로 할 때, 중간에 X가 있을 때, A - X / X - B가 많은 경로 중 가장 짧은 경로라면 전체 최적 경로도 A - X - B가 정답이 된다.

- EX) 아래 그림에서 A - X 사이의 최단 거리는 AX2이고 X - B는 BX2이다. 전체 최단 경로는 AX2 - BX2이다. 다른 경로를 택한다고 해서 전체 최단 경로가 변할 수는 없다.
  ![](https://images.velog.io/images/kcwthing1210/post/30b4446d-aa20-48f2-b458-07c29a18fd46/image.png)

- 이와 같이, 부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 된다.
  피보나치 수열도 동일하게 이전의 계산 값을 그대로 사용하여 전체 답을 구할 수 있어 최적 부분 구조를 갖고 있다.

## ✅ 구현 방법
### ✔ Bottom-Up 방식

이름에서 보이듯이, 아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.

메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

왜 Tabulation?

사실 위에서 메모하기 부분에서 Memoization이라고 했는데 Bottom-up일 때는 Tabulation이라고 부른다.

왜냐면 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 "table-filling" 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 Tabulation이라는 명칭이 붙었다고 한다.

사실상 근본적인 개념은 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memoization)와 크게 다르지 않다.

### ✔  Top-Down 방식

이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다.

피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.

이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 Memoization 이라고 부른다.


# Reference
- https://hongjw1938.tistory.com/47

# 🎁 최단경로
# 📌 최단 경로 문제
- 최단 경로 알고리즘은 가장 짧은 경로를 찾는 알고리즘을 의미함
- 다양한 문제 상황
    - 한 지점에서 다른 한 지점까지의 최단 경로
    - 한 지점에서 다른 모든 지점까지의 최단 경로
    - 모든 지점에서 다른 모든 지점까지의 최단 경로
- 각 지점은 그래프에서 노드로 표현
- 지점 간 연결된 도로는 그래프에서 간선으로 표현
  ![](https://images.velog.io/images/kcwthing1210/post/5d819877-4c66-4efc-812e-2575c9c1b24f/image.png)


# 📌 다익스트라 최단 경로 알고리즘 개요
- 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산한다
- 다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작한다
- 현실 세계의 도로(간선)은 음의 간선으로 표현되지 않습니다
- 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류된다
- 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복한다

# 다익스트라 동작과정
[초기 상태] 그래프를 준비하고 출발 노드를 설정한다
![](https://images.velog.io/images/kcwthing1210/post/22b0abb7-2b89-4488-9051-2d983dd4a479/image.png)

1. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 1번 노드를 처리한다
   ![](https://images.velog.io/images/kcwthing1210/post/2d86d53c-41d9-4c6c-a926-449836da080e/image.png)

2. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 4번 노드를 처리한다
   ![](https://images.velog.io/images/kcwthing1210/post/a769302c-e071-45c6-9063-9273232a6cf5/image.png)

3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 2번 노드를 처리한다
   ![](https://images.velog.io/images/kcwthing1210/post/59b52489-832f-4dc1-94c4-f07dab85e720/image.png)

4. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 5번 노드를 처리한다
   ![](https://images.velog.io/images/kcwthing1210/post/934a9cf1-2841-48a1-b41f-8365a11ea753/image.png)
5. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 3번 노드를 처리한다

![](https://images.velog.io/images/kcwthing1210/post/a05e2c5a-bce7-44da-91ec-eb2d3fd8fea4/image.png)

6. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 6번 노드를 처리한다
   ![](https://images.velog.io/images/kcwthing1210/post/d38a001d-5aee-419e-bbb4-9e0e321ec7f5/image.png)

## ✅ 다익스트라 알고리즘의 특징
- 그리디 알고리즘: 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해 임의의 과정을 반복한다
- 단계를 거치며 한 번 처리된 노드의 최단 거리는 고정되어 더 이상 바뀌지 않는다
- 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다
- 다익스트라 알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 거리 정보가 저장된다


# Reference
-  https://mattlee.tistory.com/50 [waca's field]
- https://freedeveloper.tistory.com/277

# 🎁 최소비용

# 📌 최소비용 신장트리(MST, Minimum Spanning Tree)란?
- 신장 트리(ST, Spanning Tree)는 사이클 없이 모든 노드를 연결하는 트리입니다.
    - 모든 정점을 포함한다.
    - 정점간 서로 연결되면서 사이클이 존재하지 않는 그래프이다.
- 그래프에 여러 개의 신장 트리가 존재할 수 있는데, 이 중 간선의 가중치 합이 최소인 것을 최소비용 신장트리(MST)라 합니다.

# 📌 Kruskal 알고리즘이란?
Kruskal 알고리즘은 최소비용 신장트리(이하 MST)를 찾는 대표적인 알고리즘입니다.
MST를 구하는 알고리즘으로 Prim 알고리즘도 있는데, Prim은 정점을 기준으로 한다면, Kruskal은 간선을 기준으로 합니다.
아래와 같은 그래프에서 MST를 찾아보겠습니다.

![](https://images.velog.io/images/kcwthing1210/post/8be71c39-11cd-4655-8ffe-089c84a78fd9/image.png)

가장 적은 비용으로 연결만 시키면 되기 때문에 간선의 가중치를 기준으로 가중치가 적은 것부터 하나씩 그래프에 포함시켜나가면 됩니다.

먼저, 위 그래프에서 간선을 오름차순으로 정렬하면 다음과 같습니다.
![](https://images.velog.io/images/kcwthing1210/post/8178993f-2133-4f05-b5ad-4f22c6c7f0bb/image.png)
그럼 위 테이블을 참고해 가중치가 적은 간선부터 하나씩 그래프에 추가해보겠습니다.
![](https://images.velog.io/images/kcwthing1210/post/824ab973-8aa7-46c4-a9b8-1cf3660cfd58/%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC.gif)

그래프에서 간선을 하나씩 추가해나가다가 사이클이 형성되는 (1, 3) 간선을 만나면 그리지않고 넘어갑니다.
그럼 간선을 추가했을 때 사이클이 형성되는지는 알기위해 Disjoint-Set 자료구조 사용

최종적인 MST는 다음과 같습니다.

![](https://images.velog.io/images/kcwthing1210/post/f268a1b3-8f24-43f8-92c4-ec1f0bd591cc/image.png)

# Reference
- https://pangtrue.tistory.com/152

