[출처 블로그](https://jy-tblog.tistory.com/38)

## 배열(Array)
* **고정된 크기**를 갖는 **같은 자료형**의 원소들이 **연속적인** 형태로 구성된 자료구조
* 인덱스(index)와 값으로 구성되어 있으며 index를 이용하여 값으로 빠르게 접근이 가능하다.
* 데이터 갯수가 확실하게 정해져 있고, 접근이 빈번한 경우 배열이 효율적이다.

<br>

### 배열의 장단점
* 장점
    * cache hit ratio가 커져 성능에 큰 도움이 된다.
    * cache hit : CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있는 경우
    * 인덱스로 random access가 가능하기 때문에 접근, 수정의 시간복잡도는 O(1)으로 빠르다.
* 단점
    * 삽입과 삭제의 경우 연속적인 형태 유지를 위해 shift 연산을 해야하므로 O(n)이 된다.
    * 초기 크기 지정(컴파일) 이후, 변경이 되지 않으므로 데이터가 삭제된다면 빈 공간으로 남아있게 되어 메모리 낭비가 생긴다.
 

<br> <br>

## 리스트(List)
* 한 원소에서 값과 다음 원소의 주소를 알고 연결하는 방식
* 빈틈없는 데이터의 적재라는 장점을 가진다.
    * 원소를 삭제했을 때 삭제된 데이터 뒤 원소로 빈틈없이 연속적으로 위치시킨다.
* 배열에서 인덱스는 유일무이한 식별자이지만 리스트에서는 몇 번째 데이터인지 정도의 의미를 가진다.
* 빈 엘리먼트는 허용하지 않는다.
* 순차성을 보장하지 못하기 때문에 spacial locality 보장이 되지 않아 cash hit가 어렵다.
    * spacial locality : 프로세서가 짧은 시간 동안 동일한 메모리 위치 세트에 반복적으로 액세스하는 경향

<br>

### 배열과 비교
* 배열과 다르게 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는다.
* 배열은 Compile time에 할당되는 정적 메모리 할당, 리스트는 새로운 Node가 추가되는 runtime에 할당되는 동적 메모리 할당
* 순차적으로 접근하기 때문에 접근, 수정의 시간복잡도는 O(n)
* 삽입, 삭제는 O(1)이지만 해당 지점까지 접근해야하므로 O(n)일 수 있음
