# 프로세스 vs 스레드

## 프로그램(Program) 이란

- 사전적 의미
    - “어떤 작업을 위해 실행할 수 있는 파일
    
    ![image](https://user-images.githubusercontent.com/47075043/148752575-c60b51e3-f115-414c-9062-08c59f2f0ab5.png)
    

## 프로세스(Process) 란

- 사전적 의미
    - “컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램”
    - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 즉, 동적인 개념으로는 실행된 프로그램을 의미한다
    
    - 컴퓨터는 디스크와 메모리, CPU로 구성되어 있고, 디스크에 저장된 프로그램을 실행시키면 메모리에
    올라가 프로세스가 되고, CPU는 여러 프로세스 중 하나씩 선택하여 실행한다.
    
    ![image](https://user-images.githubusercontent.com/47075043/148752681-056912f1-3ba7-42a0-bfec-44a65dcf44ea.png)
    

Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

## 프로세서(Processor)

- 프로세스가 동작할 수 있도록 하는 하드웨어(=cpu)

 

### 메모리의 구조

---

### 메모리의 구조

프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load)되어야 합니다.

또한, 프로그램에서 사용되는 변수들을 저장할 메모리도 필요합니다.

따라서 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공하고 있습니다.

프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간은 다음과 같습니다.

1. 코드(code) 영역

2. 데이터(data) 영역

3. 스택(stack) 영역

4. 힙(heap) 영역

다음 그림은 운영체제가 제공하는 메모리 공간을 표현하고 있습니다.

![image](https://user-images.githubusercontent.com/47075043/148752836-19a601b1-4d7b-4405-bb5e-eed7c9e76c4e.png)

---

### 코드(code) 영역

메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부릅니다.

CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

---

### 데이터(data) 영역

메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.

데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

---

### 스택(stack) 영역

메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.

스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.

이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.

스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.

이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

---

### 힙(heap) 영역

메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 동적인 메모리 영역입니다.

- Java에서는 GC가 대신 관리해줌

힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

---

- 특징
    - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
    - 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
    - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
    - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.
    Ex. 파이프, 파일, 소켓 등을 이용한 통신 방법 이용

## 스레드(Thread) 란

- 사전전 의미
    - “프로세스 내에서 실행되는 여러 흐름의 단위”
    - 프로세스의 특정한 수행 경로
    - 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 특징

![image](https://user-images.githubusercontent.com/47075043/148752884-b61e3e63-be58-4bbb-b00d-ac997eacc315.png)

- 스레드는 프로세스 내에서 각 stack 영역만 따로 할당 받고 Code, Data, Heap영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
- 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유하는 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레지스터와 스택을 가지고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

멀티 태스킹

- CPU(프로세서)에서는 한순간에 하나의 프로세스만 실행할 수 있다. 하지만 운영체제가 짧은 시간에 수십번에서 수천번 실행 할 프로세스를 교체하고 있기 때문에, 우리는 동시에 여러 개의 작업이 실행되고 있다고 느낀다.
- 운영체제가 스케줄링하면서 프로세스를 스위칭 하기위해 프로세스 상태뿐만 아니라,어떤 프로세스를 어디까지 작업했는지 알기 위한 정보등을 가지고 있는 것이 PCB 라고한다.

## PCB(Process Control Block)

### 프로세스를 제어하기 위한 정보 모음

- 프로세스 식별자(Process ID)
- 프로세스 상태
- 다음 실행할 명령어의 주소
- 이전 작업하던 내용(레지스터)
- CPU 스케줄링 정보(우선순위, 최종 실행 시각, CPU점유시간 등)
- 프로세스의 주소 공간등

![image](https://user-images.githubusercontent.com/47075043/148752935-5a88b7cb-2192-4e79-9423-92621ab32903.png)

## 멀티 프로세스와 멀티 스레드의 차이

### 멀티 프로세스

- 멀티 프로세싱이란
    - 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것이다.
- 장점
    - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
- 단점
    - Context Switching에서의 오버헤드
        - Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다.
        - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
        - 프로세스 사이의 어렵고 복잡한 통신 기법(IPC)
            - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.
        - 멀티 프로세스는 하나의 프로세스에서 사용하는 메모리 영역인 (Stack, Heap, Data, Code)를 모두 실제로 일을 하는 core에 로딩을 하게 되는데 만약 하나의 작업을 위해서 프로세스1 과 프로세스2를 사용한다고 가정하고 프로세스1에서 프로세스2로 context switching이 일어난다면 프로세스1의 메모리를 모두 내리고 프로세스2의 메모리를 모두 올려야 하는 비용이 발생할 수 있다.
            
            또한 하나의 작업을 위한 프로세스가 2개이기 때문에 프로세스1에서 프로세스2의 메모리를 참조하기 위해서는 통신을 해야만 한다.
            
            이것은 멀티 스레드를 사용해서 하나의 프로세스 내의 heap,data,code는 그대로 사용하고 stack만 해당 스레드 영역의 데이터를 사용하면 context switching 비용을 줄일 수 있다.
            
- 참고 Context Switching란?
    - CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 데 이 과정을 Context Switching라 한다.
    - 구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.
    
    ### 멀티 스레드
    
    - 멀티 스레딩이란
        - 하나의 응용프로그램을 여러개의 스레드로 구성하고 각 스레드로 하나의 작업을 처리하도록 하는 것이다.
        - 웹 서버는 대표적인 멀티 스레드 응용프로그램이다.
    - 장점
        - 시스템 자원 소모 감소( 자원의 효율성 증대)
            - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
        - 시스템 처리량 증가(처리 비용 감소)
            - 스레드 간 데이터를 주고 받는 것이 단단해지고 시스템 자원 소모가 줄어들게 된다.
            - 스레드 사이의 작업량이 작아 ContextSwitching이 빠르다.
                - pcb 레지스터 값만 바뀐다.(각각 pcb안에 있는 레지스터는 스레드마다 존재)
            
        - 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
            - 스레드는 프로세스 내의 stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
    - 단점
        - 주의 깊은 설계가 필요하다.
        - 디버깅이 까다롭다.
        - 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
        - 다른 프로세스에서 스레드를 제어할 수 없다. ( 즉, 프로세스 밖에서 스레드 각각을 제어할 수 없다.)
        - 멀티 스레드의 경우 자원 공유의 문제가 발생한다.( 동기화 문제 )
        - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.
        
        ---
        
        [https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
        
        [http://www.tcpschool.com/c/c_memory_structure](http://www.tcpschool.com/c/c_memory_structure)

        [https://www.youtube.com/watch?v=DmZnOg5Ced8](https://www.youtube.com/watch?v=DmZnOg5Ced8)
        
        질문
        
        1. 프로세스와 스레드에 대해서 설명해주세요
            1. 스레드 : 프로세스 내에서 실행되는 작업 흐름의 단위
            
            1. 프로세스 : 프로세서에 의해 동작하고 있는 프로그램
                1. 프로세스가 동작한다는 것은 프로세스의 특정 스레드가 실행 중
                2. 그 특정 스레드는 프로세스가 가진 데이터를 참조함. 
                
        2. 코어와 프로세스 차이점
            
        3. 프로세스와 스레드가 사용하는 메모리 영역 설명
        
        4. 메모리 크기를 초과하는 프로세스가 실행되고 있으면 어떻게 되는가?
        프로세스가 많이 실행되고 있는 경우 메모리의 크기를 넘어가게 될 수 있다. 이때 사용 되는 것이 ‘페이징’이다.
            
            원래 메모리에 올라와 있어야할 데이터를 디스크에 저장하는 것이다. 페이징 이라는 말 그대로 원래는 메모리 위에 올라와 있어야할 데이터를 ‘페이지’처럼 잘라서 일부는 메모리 위에, 일부는 디스크에 저장했다가 필요할 때 불러오는 방식이다. ‘어떤 페이지를 메모리에 올려 두느냐’가 중요한데 메모리에 원하는 페이지가 없으면 디스크에서 읽어 오는 만큼의 시간이 지연되기 때문이다.
            
            페이징이 하나의 프로세스를 쪼개는 거라면, 여러 프로세스 중 어떤 프로세스를 메모리에 올려둘 것인지 선택하는 것도 필요하다. 이를 선택하는 것을 ‘장기 스케줄링(Long-Term Scheduling)’이라고 한다. 그럼 ‘단기 스케줄링(Short-Term Scheduling)’도 있지 않겠는가? 단기 스케줄링은 바로 메모리에 올라와 있는 프로세스 중 어떤 프로세스를 CPU가 실행시킬지 결정하는 것을 말한다.
            
        
        5. 메모리 없이 CPU에서 바로 디스크로 접근하면 안되나?
            - 그런 구조의 컴퓨터를 만든다면 가능하다.
            - 하지만 일반적으로 컴퓨터가 디스크 > 메모리 > CPU
            의 구조를 가진 것은 다분히 경제적인 이유가 숨어있다. 디스크는 용량이 크지만, 속도가 느리다.
            메모리는 용량이 좀 더 작지만 속도는 디스크보다 월등히 빠르다. CPU는 뭔가 저장하기 위한 장치가 아니기 때문에 용량이라고 할 것도 없지만, 속도는 디스크와는 비교도 안될 만큼 빠르고 메모리 보다도 월등히 빠르다. 그럼 여기서 빠른 CPU가 디스크에서 직접 접근하여 데이터를 가져오려고 한다.
                
                이러면 CPU가 아무리 빠르다고 한들, 디스크가 데이터를 늦게 주기 때문에 처리 속도는 디스크에 맞춰질 수밖에 없다. 병목이 생기는 것이다.
                이를 극복하기 위해 중간에 메모리가 존재하는 것이다. 메모리에는 디스크에서 미리 다음에 CPU가 실행 시킬만한 데이터를 올려두는 것이다. 그럼 CPU의 속도는 메모리의 속도에 맞춰질 것이다. 
                
                하지만 이것마저도 CPU에게는 여전히 느리다. 그래서 이것을 극복하기 위해 메모리와 CPU사이에 추가적인 메모리를 두는데, 그게 바로 ‘캐시 메모리’이다. 캐시 메모리는 메모리보다 용량은 작지만 훨씬 빠르다.
                
                그래서 오늘날 우리가 사용하는 컴퓨터의 구조는 디스크 > 메모리 > 캐시 메모리 > CPU의 순서가 되었다. 이 구조는 결국 처장/처리 장치 사이의 속도 차이를 극복하여 최대한 병목을 줄이기 위해 설계된 것이다.