# 정규화 (Normalization)

데이터베이스 정규화란 데이터베이스의 설계를 재구성하는 테크닉입니다.
정규화를 통해 불필요한 데이터(redundancy)를 없앨 수 있고, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상현상(Anamolies)들을 방지할 수 있습니다. 

데이터베이스 정규화의 목적은 주로 두 가지입니다.

1. 불필요한 데이터(data redundancy)를 제거한다.
2. 데이터 저장을 "논리적으로" 한다.

우선 정규화를 안 했을 때의 문제점에 대해서 알아보겠습니다.

![image](https://t1.daumcdn.net/cfile/tistory/9999183359E7852802)

위와 같이 정규화가 되지 않은 구조의 테이블(Adam이라는 학생이 두 번 들어가 있습니다.)의 경우, 데이터 핸들링시 다양한 이상현상이 발생하게 됩니다.

1. Update : Adam의 Address가 변경되었을 때, 여러줄의 데이터를 갱신해야합니다. 이로인해 데이터의 불일치(inconsistency)가 발생할 수 있습니다.

2. Insert : 만약 학생이 아무 과목도 수강하지 않는다고 하면, Subject_opted 컬럼에는 NULL이 들어갈 것입니다.

3. Deletion : 만약 Alex 학생이 과목 수강을 취소한다면 Alex의 레코드가 아예 테이블에서 지워져버립니다.

위와 같이 정규화가 제대로 되지 않은 테이블의 경우 갱신/삽입/삭제 시 다양한 문제점이 발생할 수 있습니다. 이를 테이블의 구성을 논리적으로 변경하여 해결하고자 하는 것이 바로 정규화입니다.

정규화의 법칙(Normalization Rule)은 1차정규화, 2차정규화, 3차정규화, BCNF, 4차정규화, 5차정규화로 나눌 수 있는데, 4차, 5차 정규화까지 하는 경우는 많지 않다고 합니다. 

## 장점 
- 데이터베이스 변경 시 이상 현상(Anomaly) 제거
- 저장 공간의 최소화 가능
- 효과적인 검색 알고리즘 생성 가능
- 데이터 삽입 시 릴레이션 재구성의 필요성 감소
- 데이터 구조의 안정성 및 무결성 유지

## 단점
- 릴레이션 간의 JOIN 연산 증가
    - 이로 인한 질의에 대한 응답 시간 저하

## 정규화 원칙

- 정보의 무손실 표현
    - 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는 안 된다.

- 분리의 원칙
    - 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.

- 데이터의 중복성이 감소되어야 한다.

# 정규화 종류

## 제1 정규화

제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다.

예를 들어, 아래와 같은 경우 Adam의 Subject가 Biology와 Maths 두 개 이기 때문에 1차 정규형을 만족하지 못합니다.

![image](https://t1.daumcdn.net/cfile/tistory/9983DA3359E7855B34)

위의 정보를 표현하고 싶은 경우 이렇게 한 개의 로우를 더 만들게 됩니다. 결과적으로 1차 정규화를 함으로써 데이터 중복성은 더 증가하였습니다. 데이터의 논리적 구성을 위해 이 부분을 희생하는 것으로 볼 수 있습니다.

![image](https://t1.daumcdn.net/cfile/tistory/9967D83359E7861E07)

## 제2 정규화

2차 정규형은 테이블의 모든 컬럼이 **완전 함수적 종속**을 만족하는 것입니다.

기본키중에 특정 컬럼에만 종속된 컬럼(부분적 종속)이 없어야 한다는 것입니다.

위 테이블의 경우 기본키는 (Student, Subject) 두 개로 볼 수 있습니다. 이 두 개가 합쳐져야 한 로우를 구분할 수가 있습니다. 

근데 Age의 경우 이 기본키중에 Student에만 종속되어 있습니다. 즉, Student 컬럼의 값을 알면 Age의 값을 알 수 있습니다. 따라서 Age가 두 번 들어가는 것은 불필요한 것으로 볼 수 있습니다.

**Student Table**
![image](https://t1.daumcdn.net/cfile/tistory/99589D3359E789FA30)

**Subject Table**
![image](https://t1.daumcdn.net/cfile/tistory/99C5183359E789FB14)

이를 해결하기 위한 방법은 위처럼 테이블을 쪼개는 것입니다. 그러면 두 테이블 모두 2차 정규형을 만족하게 됩니다. 위 테이블의 경우 삽입/갱신/삭제 이상을 겪지 않게됩니다. 하지만 조금 더 복잡한 테이블의 경우, 갱신 이상을 겪기도하는데 이를 해결하는 것이 바로 3차 정규화입니다.

## 3차 정규화

![image](https://t1.daumcdn.net/cfile/tistory/99E0403359E78AEE2B)

이와 같은 데이터 구성을 생각해봅시다. Student_id가 기본키이고, 기본키가 하나이므로 2차 정규형은 만족하는 것으로 볼 수 있습니다. 하지만 이 데이터의 Zip컬럼을 알면 Street, City, State를 결정할 수 있습니다. 또한 여러명의 학생들이 같은 Zip코드를 갖는 경우에 Zip코드만 알면 Street, City, State가 결정되기 때문이 이 컬럼들에는 중복된 데이터가 생길 가능성이 있습니다. 정리하면 3차 정규형은 기본키를 제외한 속성들 간의 **이행적 함수 종속**이 없는 것 입니다. 풀어서 말하자면, 기본키 이외의 다른 컬럼이 그외 다른 컬럼을 결정할 수 없는 것입니다.


3차 정규화는 2차정규화와 마찬가지로 테이블을 분리함으로써 해결할 수 있는데, 이렇게 두 개의 테이블로 나눔으로써 3차 정규형을 만족할 수 있습니다. 이를 통해 데이터가 논리적인 단위(학생, 주소)로 분리될 수 있고, 데이터의 중복성도 줄었음을 알 수 있습니다.

![image](https://t1.daumcdn.net/cfile/tistory/994C193359E78C5E4A)

## 4. BCNF

BCNF는 (Boyce and Codd Normal Form) 3차 정규형을 조금 더 강화한 버전으로 볼 수 있습니다. 이는 3차 정규형으로 해결할 수 없는 이상현상을 해결할 수 있습니다.

BCNF란 3차정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형입니다. 

아래와 같은 경우를 생각해보면, 후보키는 수퍼키중에서 최소성을 만족하는 건데, 이 경우 (학생, 과목) 입니다. (학생, 과목)은 그 로우를 유일하게 구분할 수 있습니다. 

근데 이 테이블의 경우 교수가 결정자 입니다. (교수가 한 과목만 강의할 수 있다고 가정) 즉, 교수가 정해지면 과목이 결정됩니다. 근데 교수는 후보키가 아닙니다. 

따라서 이 경우에 BCNF를 만족하지 못한다고 합니다. 3차 정규형을 만족하면서 BCNF는 만족하지 않는 경우는 언제일까요? 바로 일반 컬럼이 후보키를 결정하는 경우입니다.

![image](https://user-images.githubusercontent.com/47075043/158722116-214c6c88-7169-4dda-8d70-118957eda945.png)


위와 같이 테이블이 구성된 경우에 데이터가 중복되고, 갱신 이상이 발생합니다. 

예를 들어 Mr.Sim이 강의하는 과목명이 바뀌었다면 두 개의 로우를 갱신해야합니다. 이를 해결하기 위해서는 마찬가지로 테이블을 분리합니다.

![image](https://user-images.githubusercontent.com/47075043/158722156-d86f653d-1fcc-4e20-b400-656f3ecdbfba.png)


## 비정규화(Denormalization, 반정규화)

하나 이상의 테이블에 데이터를 중복해 배치하는 최적화 기법이다.

시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위이다.

비정규화는 다른 타협안을 내놓음으로써 그런 단점을 해소하고자 한다. 어느 정도의 데이터 중복이나 그로 인해 발생하는 데이터 갱신 비용은 감수하는 대신 조인 횟수를 줄여 한층 효율적인 쿼리를 날릴 수 있도록 하겠다는 것이다.

### 장점
- 빠른 데이터 조회
    - 조인 비용이 줄어들기 때문

- 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단해짐
    - 따라서 버그 발생 가능성도 줄어든다

### 단점
- 데이터 갱신이나 삽입 비용이 높음
- 데이터 갱신 또는 삽입 코드를 작성하기 어려워짐
- 데이터 간의 일관성이 깨어질 수 있다. 어느 쪽이 올바른 값인가?
- 데이터를 중복하여 저장하므로 더 많은 저장 공간이 필요

## 비정규화 대상
- 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
- 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
- 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우
- 대부분의 대규모 IT 업체의 경우처럼, 규모 확장성(scalability)을 요구하는 시스템의 경우 거의 항상 정규화된 데이터베이스와 비정규화된 데이터베이스를 섞어 사용한다.

### 주의점
반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다.
입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.


출처: 

https://3months.tistory.com/193

https://owlyr.tistory.com/20#113a77b2-e481-43f8-a1b3-b31f767e9803




