# List

배열은 다수의 데이터를 그룹핑해서 효율적으로 관리할 수 있는 데이터 스트럭쳐입니다.

배열의 가장 큰 특징은 인덱스가 있다는 것입니다. 

만약 인덱스를 알고 있다면 인덱스를 이용해서 데이터를 가져올 수 있습니다. 인덱스를 이용한 데이터의 조회는 매우 빠르게 처리 됩니다. 

**하지만 인덱스를 이용해서 데이터를 가져오려면 데이터에 대한 인덱스의 값이 고정되어야 합니다.**

자연스럽게 어떤 엘리먼트가 삭제되면 삭제된 상태를 빈 공간으로 남겨둬야 합니다. 이것은 메모리의 낭비를 초래합니다. 또한 배열에 데이터가 있는지 없는지를 체크하는 로직이 필요하다는 의미이기도 합니다.

**리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신 빈틈없는 데이터의 적재라는 장점을 취한 데이터 스트럭쳐**라고 할 수 있습니다

## 삭제

![image](https://user-images.githubusercontent.com/47075043/154861416-35c54e5c-a07d-4eb9-bf4e-44106f73ee38.png)

원본 데이터 중 값이 40인 데이터를 제외시키면 배열이라면 40이 없어진 자리가 빈자리로 남아 있을 것입니다.

덕분에 50의 인덱스 값은 변하지 않았습니다. 즉 인덱스가 주민등록 번호처럼 변하지 않는 고유한 값으로 남아있게 되는 것이죠.

하지만 리스트를 이용하면 40이 있던 공간에 50이 채워지게 됩니다.

즉 데이터 밀도를 촘촘하게 유지할 수 있게 됩니다. 하지만 50의 인덱스 값은 4에서 3으로 변경되었습니다. 즉 인덱스는 더 이상 식별자로 사용할 수 없습니다.

추가도 삭제와 반대로 똑같습니다.

## 리스트의 기능
- 리스트의 핵심적인 개념은 순서가 있는 엘리먼트의 모임이라는 것입니다. 

- 빈 엘리먼트는 허용되지 않는다.

- 중복된 데이터를 허용한다.

- 중복 허용은 배열과 리스트의 차이가 아닙니다. 배열도 중복이 허용됩니다. set과 같은 데이터 스트럭쳐와의 차이


리스트를 직접 구현하는 것도 좋지만, 자신이 사용하고 있는 언어에 이미 리스트가 내장되어 있다면 그것을 사용해야 합니다. 

## 자료구조의 두 가지 구현 방법

자료구조는 구현 방법에 따라 크게 두 갈래로 분류할 수 있습니다.
바로 순차(Sequential) 자료구조와 연결(Linked) 자료구조입니다.

**순차 자료구조**는 구현할 자료들을 논리적인 순서대로 메모리에 **연속**하여 저장하는 자료구조입니다.

데이터가 컴퓨터 메모리에 저장될 때, 저장 시작 위치부터 **빈자리 없이 순서대로** 저장된다는 뜻인데요.
 
자료의 **논리적인 순서와 물리적인 순서가 일치하는** 구현 방식이라고 할 수 있습니다.

- 크기가 가변적이다.

- 내부적으로 배열을 사용하기 때문에(인덱스를 이용해서) 접근하는 것이 빠르다.

- add(), remove()를 통해 추가/삭제가 가능하다.
    - 데이터 추가/삭제 시 메모리를 재할당하기 때문에 속도가 배열보다 느리다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8GlEl%2FbtquuJp5dJr%2FaN5jFc2e4DMBkKuxjelzvK%2Fimg.png)

---

**연결 자료구조는** 메모리에 저장된 물리적 위치나 순서와 상관없이, 링크에 의해 논리적인 순서를 표현하는 자료구조입니다.

연속적인 메모리에 저장되는 방식이 아니라 **노드**라는 각각의 독립된 공간을 사용해 데이터를 담습니다.

노드는 실제 데이터가 저장되는 공간인 **데이터 필드와 다음 노드의 주소 값을 가진 링크 필드로** 이루어져 있습니다.

- 즉, 메모리를 연속적으로 사용하지 않는다. 

- 순차적 접근방식이다. 즉, 특정 원소에 접근하기 위해서 처음부터 검색하면서 찾는다. 

- 동적으로 삽입, 삭제가 편하다.

- 원소를 삽입할 경우
    - 맨 앞 , 맨 뒤 삽입은 위치를 찾지 않아도 되서 시간 복잡도 O(1)이다.
    - 중간 삽입은 이전 노드와 다음 노드의 위치를 알고 있는 경우 시간 복잡도는 O(1)이다.
    - 하지만 탐색을 해야하는 경우 시간 복잡도 O(n)이다.

- 원소를 삭제할 경우
    - 삽입과 마찬가지로 맨 앞, 맨 뒤 삭제는 시간 복잡도 O(1)이다.
    - 중간 삭제는 시간 복잡도 O(n) 또는 O(1)이다. (삽입과 같음)

- 특정 위치에 있는 원소에 바로 접근이 불가능하다. (주소를 바로 알 수 없기 때문)
    - 원하는 원소를 찾기 위해서 최소 한 번은 리스트를 순회해야하기 때문에 시간 복잡도는 O(n)이다.

- 메모리는 새로운 노드가 추가될 때 (Runtime) Heap 영역에 할당한다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fl0VVL%2FbtquxsmG8P6%2Fnxm8KVIBfzq4LttQHf2CvK%2Fimg.png)

### ArrayList vs LinkedList 시간 복잡도

|| 	ArrayList|	LinkedList|
|---|---|---|
|get / set	|O(1)	|O(n)|
|add(시작)	|O(n)	|O(1)|
|add(끝)	|O(1)	|O(1)|
|add(일반)	|O(n)	|O(n)|
|remove(시작)|	O(n)|	O(1)|
|remove(끝)	|O(1)	|O(1)|
|remove(일반)	|O(n)|	O(n)|

참고 : 

https://hee96-story.tistory.com/46

https://opentutorials.org/module/1335/8636

https://brightwon.tistory.com/3

https://www.nextree.co.kr/p6506/
