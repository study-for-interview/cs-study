# 최단 경로 알고리즘

그래프에서 각 정점끼리 사이의 최단 거리를 구하는 알고리즘 방법은 여러 가지가 있다. 문제에 따라 효율적인 방법이 다르므로 잘 선택해서 사용해야 한다.

### 문제의 종류
- 하나의 정점에서 다른 하나의 정점까지 최단 경로를 구하는 문제
- 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제
- 각 모든 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제

응용으로 한 중간 정점을 거쳐서 가는 최단경로 등 다양한 문제의 종류에 적용하여 사용할 수 있다.

# 알고리즘 종류

하나의 정점에서 다른 모든 정점까지 최단경로를 구하는 문제

- 간선의 가중치가 모두 같은 그래프일 경우
  - BFS

- 간선의 가중치가 각각 다른 그래프일 경우
  - 다익스트라
  - 벨만-포드 → 음수 가중치의 간선이 존재할 때

- 하나의 정점에서 다른 모든 정점까지 최단경로를 구하는 문제
  - 플로이드 와샬


# 다익스트라

다익스트라 알고리즘은, 그래프 내의 특정 정점에서 갈 수 있는 모든 정점들까지의 최단 경로를 구하는 알고리즘입니다.

다익스트라 알고리즘은 그 방식이 효율적이라 그래프가 큰 경우에도 사용 가능한 장점이 있습니다.

하지만, 그래프 내 간선의 가중치가 음수인 것이 하나라도 있다면 사용할 수가 없습니다.

## 다익스트라 과정

![image](https://i.imgur.com/xmSTwmo.png)

1번 정점에서 시작해서 모든 정점들까지의 최단 경로를 구한다고 가정해 보겠습니다.

정점들 간의 간선의 가중치는 그림과 같고, distance 배열은 1번 정점에서 특정 정점까지의 최단 경로 길이를 표시해 놓습니다.

단, 초기에는 최단 경로를 구하지 않은 상태이므로 무한대(아주 큰 값)로 표시합니다.

![image](https://i.imgur.com/PqEubsG.png)
![image](https://i.imgur.com/UvwvTEg.png)
![image](https://i.imgur.com/Z5mkKmS.png)

1번 정점에서 인접한 정점들을 살펴봅니다.

처음에는 모두 무한대 값들이었으므로, 1번 — 특정 정점 까지의 간선 가중치로 모두 업데이트가 될 것입니다.

즉, distance[특정 정점] 과 distance[1] + (1번 정점과 특정 정점 사이 가중치) 를 비교해 더 작은 값으로 distance[특정 정점] 을 업데이트합니다.

이것이 다익스트라 알고리즘의 핵심입니다.

![image](https://i.imgur.com/tWv7jcY.png)

이제 5번 정점에서 인접 정점을 살펴봅니다. 1번은 이미 처리했으므로, 4번 정점과의 거리만 살펴봅니다.

distance[4] 값은 1에서 바로 4로 갈 때의 거리인 9 였는데, 5번 정점에서 살펴보니, 1번에서 5번을 거쳐(distance[5]), 4번으로 가는 경로(5와 4 사이 가중치) 가 더 짧음을 알 수 있습니다.

즉, distance[4] > distance[5] + 2 이므로, distance[4] 를 distance[5]+2 로 업데이트합니다.

다음 정점들에 대해서도 이제 마찬가지로 수행하면 됩니다.

![image](https://i.imgur.com/8wDAQGU.png)

![image](https://i.imgur.com/ki9XkdO.png)

![image](https://i.imgur.com/AHtflyf.png)

## 다익스트라 시간복잡도

다익스트라 알고리즘은 크게 각 정점마다 인접한 간선들을 탐색하는 과정과 우선순위 큐에 [거리, 정점] 정보를 넣고 빼는 과정으로 나뉜다.

- 각 정점마다 인접한 간선들을 탐색하는 과정
각 노드는 최대 한 번씩 방문하기 때문에 그래프의 모든 간선은 최대 한 번씩 검사한다. 따라서 이 과정의 시간 복잡도는 O(E)이다.

- 우선순위 큐에 [거리, 정점] 정보를 넣고 빼는 과정
최악의 경우는 모든 간선을 검사할 때 마다 거리 값 리스트가 갱신되고, 우선순위 큐에 정보가 저장되는 경우이다. E개의 간선을 검사할 때 마다 우선순위 큐를 유지해야 하므로 이 과정의 시간 복잡도는 O(ElogE)이다.

위 두 과정을 거칠 경우 다익스트라 알고리즘의 총 시간 복잡도는 O(E)+O(ElogE)=O(ElogE) 가 된다.

인접 행렬로 구현할 경우 O(V^2)을 가지게 된다.

---

# 플로이드 와샬

Floyd-Warshall 알고리즘이란, 모든 최단 경로를 구하는 방법 입니다.


모든 노드 간의 최단거리를 구해야 하므로 2차원 인접 행렬을 구성합니다. 알고리즘은 여러 라운드로 구성됩니다. 라운드마다 각 경로에서 새로운 중간 노드로 사용할 수 있는 노드를 선택하고, 더 짧은 길이를 선택하여 줄이는 과정을 반복합니다.

플로이드 와샬 알고리즘의 총 시간 복잡도는 O(N^3) 이다.

플로이드 알고리즘은 경로의 경유점 개념을 알아야한다. 두 정점 u, v를 잇는 어떤 경로가 있다고 할때 이 경로는 시작점 u와 끝점 v를 가지는 것이다. 이 외에 이 경로는 다른 정점들을 지나쳐 갈 수 도 있다.

- u와 v를 직접 연결하는 간선이 없거나, 다른 정점을 경유해서 가는 편이 전체 경로가 더 짧아지기 때문이다. 이와 같이 경로가 거쳐가는 정점들을 경유점이라 한다.

아래와 같은 그래프가 존재할 때 플로이드 와샬 알고리즘을 통해 모든 정점들의 최단 경로를 구해보자.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzjZO8%2FbtqZhfFs4Jz%2FgC4namknziGzmr1Vpakkm0%2Fimg.png)

각각의 정점이 다른 정점으로 가는 비용을 이차원 배열로 출력하면 다음과 같다. 
```
 	1	2	3	4
1	0	5	inf	8
2	7	0	9	inf
3	2	inf	0	4
4	inf	inf	3	0
```

이제 각각의 노드를 차례대로 기준으로 잡고 최단 경로를 구하면 된다

1) 노드 1을 거쳐가는 경우

1을 거쳐서 가는 경우가 더 빠르다면 그 경우로 최단 경로의 길이를 갱신해주는 것으로 파란색으로 된 6곳만 갱신이 되었다

### X에서 Y로 가는 최소 비용 VS X에서 노드 1로 가는 비용 + 노드 1에서 Y로 가는 비용

```
	1	2	3	4
1	0	5	inf	8
2	7	0	9	15
3	2	7	0	4
4	inf	inf	3	0
```

2) 노드 2을 거쳐가는 경우

노드 1과 마찬가지로 계산을 해주면 된다
```
 	1	2	3	4
1	0	5	14	8
2	7	0	9	15
3	2	7	0	4
4	inf	inf	3	0
```

위와 같은 방식으로 노드3, 노드4도 수행해주면 최종적으로 아래와 같은 결과가 나오게 된다

```
	1	2	3	4
1	0	5	11	8
2	7	0	9	13
3	2	7	0	4
4	5	10	3	0
```


## 다익스트라(Dijkstra) vs 플로이드 와샬(Floyd Warshall) 정리


 	다익스트라(Dijkstra)	플로이드 와샬(Floyd Warshall)
용도	한 정점 → 다른 모든 정점 최단 거리를 구할 때	모든 정점 → 모든 정점 최단 거리를 구할 때
공간복잡도	인접행렬 O(V^2)
인접리스트 O(V+E) - 사용 권장	이차원배열 O(V^2) 
시간 복잡도	인접행렬 O(V^2)
인접리스트 + 우선순위 큐 O((V+E)logV)	3중 포문 O(V^3)

||다익스트라(Dijkstra)|플로이드 와샬(Floyd Warshall)|
|------|---|---|
|용도|한 정점 → 다른 모든 정점 최단 거리를 구할 때|모든 정점 → 모든 정점 최단 거리를 구할 때|
|공간 복잡도|	인접행렬 O(V^2) / 인접리스트 O(V+E)|이차원배열 O(V^2) |
|시간 복잡도|	인접행렬 O(V^2) / 인접리스트 + 우선순위 큐 O((V+E)logV)|	3중 포문 O(V^3)|


---
참고

[다익스트라](https://chanhuiseok.github.io/posts/algo-47/)

https://loosie.tistory.com/146
