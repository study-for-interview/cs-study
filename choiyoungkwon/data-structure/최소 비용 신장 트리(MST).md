# MST란?

spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리.

MST는 간선에 가중치를 고려하여 최소 비용의 스패닝 트리를 선택하는 것,

# 신장 트리(Spanning tree)와 최소 신장 트리

신장 트리(Spannging tree)는 다음과 같이 정의합니다.
```
그래프에서
(1) 모든 정점을 포함하고, 
(2) 정점 간 서로 연결이 되며 싸이클이 존재하지 않는(tree의 기본 조건) 그래프
```

예를 들어 아래와 같은 그래프가 있다고 가정해 보겠습니다.

![image](https://i.imgur.com/4wIFiNX.png)

여기서 나올 수 있는 신장 트리들은 여러 가지인데, 아래와 같은 예시가 있을 수 있습니다.

![image](https://i.imgur.com/Hke4maA.png)

모든 정점이 포함되어 있으면서, 모든 노드는 적어도 하나의 간선으로 연결되어 있습니다.

또한, 연결 관계에서 사이클을 형성하지 않습니다.

따라서 신장 트리는 정점의 갯수가 n개일 때, 간선이 n-1개가 됩니다.

간선 위에 적힌 숫자는 그 간선의 가중치를 말합니다.
왼쪽 그래프는 가중치가 1+5+6+4=16 이고, 오른쪽 그래프는 가중치가 1+2+6+4 = 13 이 됩니다.

이렇게 **신장 트리들 중에서 가중치의 합이 최소가 되는 신장 트리를 최소 신장 트리(Minimum Spanning Tree, MST)**라고 합니다.

이 그래프에서는 아래와 같은 경우입니다.

![image](https://i.imgur.com/mCywucG.png)

위 그래프를 최소 신장 트리(최소 비용 신장 트리)라고 합니다.

크루스칼 알고리즘은 바로 이 최소 신장 트리를 구하기 위한 알고리즘입니다.

## 최소 신장 트리를 구하는 문제의 예시

- 여러 개의 네트워크 지점들이 있는데, 모든 지점들을 유선으로 연결하되 연결선의 총 길이가 최소가 되야 하는 문제
- 도시들을 모두 연결하되, 연결하는 도로의 길이 합이 최소가 되야 하는 문제

# 크루스칼 알고리즘의 과정

크루스칼 알고리즘은 그리디 알고리즘의 일종입니다.

즉, 그래프 간선들을 가중치의 오름차순으로 정렬해 놓은 뒤, 사이클을 형성하지 않는 선에서 정렬된 순서대로 간선을 선택합니다.

### 1. 그래프 간선을 가중치 오름차순 정렬합니다.

![image](https://i.imgur.com/FZP5haF.png)

### 2. a-b 부터 선택합니다.

![image](https://i.imgur.com/cygqIT7.png)

### 3. 그 다음 a-d를 선택합니다.

![image](https://i.imgur.com/TzWXNYV.png)

### 4. 그 다음 b-d를 선택하면 a-b-d 사이클이 형성되므로 선택하지 않습니다.

![image](https://i.imgur.com/si8xA9K.png)

### 5. 그 다음 b-c를 선택합니다. 선택된 간선의 갯수가, 정점의 갯수-1 만큼 되면 종료합니다.

![image](https://i.imgur.com/PQZwcsT.png)

## 사이클 생성 여부를 확인하는 방법
- 추가하고자 하는 간선의 양끝 정점이 같은 집합에 속해 있는지를 먼저 검사해야 한다.
- **union-find** 알고리즘 이용

- Union-Find 란?
    - Disjoint Set (서로소 집합) 을 표현하는 자료구조
    - 서로 다른 두 집합을 병합하는 Union 연산, 집합 원소가 어떤 집합에 속해있는지 찾는 Find 연산을 지원하기에 이러한 이름이 붙었음

![image](https://i.imgur.com/86KWwvq.png)

간선 선택 전, 1번~4번 노드는 초기에 각각 서로소 집합 {1}, {2}, {3}, {4}로 표현될 수 있습니다.

- parent 배열은 각 정점의 root node(부모)를 표현한 배열
- 초기에는 자기 자신이 루트 노드가 되게 초기화 되어 있는 상태 (parent[i] = i)

가중치의 오름차순 정렬한 순서대로 간선 1-2 를 선택합니다.

![image](https://i.imgur.com/CYrGgbs.png)

이 때, 1번과 2번이 같은 집합으로 Union 연산에 의해 합쳐진 것입니다. 그리고 2번의 부모는 1번이 됩니다.

![image](https://i.imgur.com/7M5otWE.png)

즉, 위에서 1-2 를 연결하면서 Union 연산에 의해 {1}, {2} 집합이 합쳐져서, 서로소 집합 {1, 2}, {3}, {4} 가 된 것입니다.

{1}, {2} 가 서로 합쳐질 수 있는 이유는 각 집합의 루트 노드가 다른 값 (1과 2)이었기 때문입니다.
({1}의 root node는 1, {2}의 root node는 2)

그리고 그 집합 내에서 제일 작은 숫자가 그 집합에서의 루트 노드(root node) 가 되게끔 가정합니다.

즉, 서로 루트 노드(부모)가 다른지 판단하고, 다르다면 Union 연산으로 합칩니다.

그 결과 2번 노드의 부모 노드는 1번이 되었으며, 1번과 2번은 같은 집합이 되었습니다.

다음으로 간선 1-4를 선택합니다.

![image](https://i.imgur.com/NkvosVX.png)
![image](https://i.imgur.com/TXF8MnU.png)

1과 4를 연결해야 합니다. 1의 루트 노드는 1이고, 4의 루트 노드는 4 이므로 서로 다른 부모를 가집니다.

따라서 Union 연산으로 합칠 수 있으며, 합친 결과 {1, 2, 4} 집합이 되었습니다.

그리고 {1, 2, 4} 집합에서 루트 노드는 1 입니다. 즉, 2번의 부모는 1번이고, 4번의 부모도 1번입니다.

다음으로 간선 2-4를 선택합니다.

![image](https://i.imgur.com/rgAlCM4.png)

2와 4를 연결해야 합니다. 그런데, 2의 루트 노드는 1이고, 4의 루트 노드도 1 입니다.
(parent[2] = 1, parent[4] = 1 –> parent[2] == parent[4])

서로 부모가 같기 때문에 Union 연산을 하지 않습니다. 만약 합친다면 위 그래프처럼 사이클을 형성하게 되기 때문입니다.

집합 관점에서는, 이미 2와 4가 같은 집합에 속해 있으므로 거기서 또다시 Union 연산을 할 수 없는 것입니다.

# 프림 알고리즘 (Prim Algorithm)

- 시작 정점을 기준으로 가장 작은 간선과 연결된 정점을 선택하며 신장 트리를 확장 시키는 알고리즘
- 정점 선택을 기반으로 하는 알고리즘

## 동작 원리

- 임의의 간선을 선택
- 선택한 간선의 정점으로부터 가장 낮은 가중치를 갖는 정점을 선택
- 모든 정점이 선택될 때까지 반복


![image](https://media.vlpt.us/images/fldfls/post/4b407297-f4c6-4487-a62b-4d5f52fa64f3/image.png)

참고 : 

https://chanhuiseok.github.io/posts/algo-33/

https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html

