# TCP/IP란 
 TCP / IP 4계층

OSI(Open Systems Interconnections) 7계층은 시스템들의 연결을 위한 모델입니다.

TCP/IP 4계층은 이를 웹서비스에 맞게 단순화 시킨 모델입니다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkFxIw%2FbtqKMON83Dc%2FkrwjBqZjexMqfSOSv4WCfk%2Fimg.png)

 1. Application Layer(응용 계층)

    - 이 계층은 네트웍을 사용하는 응용프로그램(FTP, Telnet, SMTP) 등으로 이루어지며, OSI 계층의 Aplication Layer 와 Presentation Layer 를 모두 포함한다.

2. Transport Layer(전송 계층)

   - 계층의 이름에서 알수 있듯이, 도착을 원하는 시스템까지 데이타를 전송하기 위한 일을 하는 게층이다. OSI 모델의 Session Layer 과 Transport Layer 를 포함하고 있으며, 각각의 시스템을 연결하고, TCP 프로토콜을 이용하여 데이터를 전송한다.

3. Internet Layer(인터넷 계층)

   - 데이타를 정의하고 데이타의 경로를 배정하는일(라우팅)을 담당한다. 데이타를 정확히 라우팅 하기 위해서 IP프로토콜을 사용한다. OSI 의 Network Layer 과 Data Link Layer 를 포함한다.

4. Physical Layer(물리 계층)

물리적 계층 즉 이더넷 카드와 같은 하드웨어를 말한다.

##  TCP/IP 4계층에 의한 데이터 전송

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbbZpYp%2FbtqKLEypkYn%2FEl2csyTckLCgPzh8ikq3NK%2Fimg.png)

WWW (World Wide Web)은 더이상 설멍이 필요없는 유명한 서비스로써, HTTP (HyperText Transfor Protocol)이라는 프로토콜을 이용한다.위의 그림을 설명해 보자면, 일단 사용자는 Mozilla 나 IE 같은 브라우저를 사용하여서 www.naver.com과 같은 URL 입력을 통해서 웹 페이지를 요청한다.  

사용자의 요청(문자)은 인터넷상에서 전달되기 용이한 패킷으로 만들기 위해서 TCP 패킷으로 만들어지게 된다.

이것은 다시 인터넷 상에서 원하는 주소로 이동할수 있도록 하기 위해서 IP 패킷으로 다시 만들어 지고(IP 패킷에는 자신의 주소와, 도착해야될 상대방의 주소정보가 들어있을것이다) 이것은 이더넷 카드로 보내어져서 Internet 으로 나가게 된다.

Internet 상에서는 원하는 주소로 TCP/IP 패킷을 보내기 위한 여러가지 장치들이 존재하는데(라우터, 토큰링 같은), 이들 장치를 통해서, www.naver.com 의 이더넷카드로 TCP/IP 패킷이 전달되게 된다.

그럼 이더넷 카드는 TCP/IP 패킷을 바로 윗 계층(Internet Layer)으로 보내는데, 여기에서는 IP 패킷을 분석해서, 이 패킷이 어디에서 왔으며, 그 도착지가 어디인지를 판단하게 된다.(물론 이는 IP주소 기반으로 판단한다)

그리하여 목적지가 자신이면 이것을 다시 Transport Layer 로 보내고, TCP 프로토콜을 사용하여, 메시지가 누락된게 있으면 다시 요청하고, 순서를 재조합하는등 통신 메시지를 검사해서 이것을 다시 Application Layer 에게 보낸다.

Application Layer 에서는 웹서버(IIS, Apache 같은)가 통신메시지를 HTTP 프로토콜에 준하여, 검사를 하여서 사용자가 요청한 웹페이지를 읽어들여서, Transport 계층으로 보내게 된다.

웹페이지를 브라우저까지 전송하는 과정은 위의 정반대의 과정을 순차적으로 거치게 된다.

최종적으로 웹브라우저는 웹페이지를 받아서(text) 역시 HTTP 프로토콜에 준하여, 렌더링 작업을 거친후 화면에 뿌려주게 된다.

위의 그림에서 보면 알겠지만 각각의 계층은 각각의 계층만을 상관하고 있음을 알수 있다.

즉 Application Layer 에 위치하는 브라우저와 webserver 는 HTTP 프로토콜에 의해서 자신의 계층끼리만 통신을 하고, Transport Layer 은 역시 TCP 프로토콜에 의해서 Transport Layer 끼리 통시을 함을 알수 있을것이다. 말그대로 계층적 구조를 가지며, 각 계층은 대응되는 상대편의 계층에 대해서만 상관한다.

# TCP 3-way handshake
```
TCP/IP 4 계층을 통과하며 수신 측으로 데이터를 보낼 준비가 완료됐습니다. 하지만 TCP는 데이터를 전송하기 전에 네트워크 연결을 설정하는 과정이 필요합니다. 이 과정을 3-way handshake라고 합니다.

3-way handshake를 수행하기 위해서는 TCP 헤더에 표시한 SYN과 ACK 플래그들이 사용됩니다.
```

![image](https://user-images.githubusercontent.com/55661631/141071760-93ecafd1-bcbb-411c-bd57-e6fa7dfc0553.png)

1. 클라이언트는 서버에게 접속을 요청하는 SYN 플래그가 설정된 패킷을 보냅니다.
2. 이때 서버는 Listen 상태로 포트 서비스가 가능한 상태여야 합니다. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN 플래그가 설정된 패킷을 발송하고 응답을 기다립니다.
3. 클라이언트는 서버로부터 ACK와 SYN 플래그가 설정된 패킷을 받고 ACK 플래그가 설정된 패킷을 발송합니다.
4. 연결이 이루어지고 데이터가 오가게 됩니다.

```
추가로 알면 좋은 내용
현재 저장된 송신 측의 IP는 Private IP를 사용하고 있어 공유기를 통해 나가기 전에 NAT 작업을 통해 Public IP로 변환됩니다. 송신 측의 공유기를 거치고 나서, 구글 서버에 도착하기 위해 여러 라우터를 거쳐야 합니다. 이 과정을 라우팅이라고 합니다. 라우팅을 거쳐 구글(수신 측) 서버의 라우터까지 데이터가 도착하면 IP 헤더에 적힌 구글 서버의 IP주소로 MAC 주소를 요청한 후 물리적인 데이터 전송을 완료합니다.
```

# TCP 4-way handshake
데이터 송 수신이 완료되면 TCP의 연결을 해제하는 과정이 필요합니다. 이 과정을 4-way handshake라고 합니다.

4-way handshake를 수행하기 위해서는 TCP 헤더에 표시한 ACK와 FIN 플래그들이 사용됩니다.

![image](https://user-images.githubusercontent.com/55661631/141071848-418dfaaa-d528-4e57-ac4c-0fb66b20b4a5.png)

1. 클라이언트가 서버에게 연결을 종료하겠다는 FIN 플래그가 설정된 패킷을 보냅니다.
2. 서버는 확인했다고 알려주기 위해 ACK 플래그가 설정된 패킷을 보낸 후 자신의 통신이 끝날 때까지 기다립니다(TIME_WAIT). 이때, 자신이 전송할 패킷이 남아있다면 이어서 전송합니다.
3. 서버의 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 클라이언트에게 FIN 플래그가 설정된 패킷을 보냅니다.
4. 클라이언트는 확인했다는 의미로 ACK 플래그가 설정된 패킷을 보냅니다.
5. 연결이 종료됩니다.


# TCP/IP 흐름제어 
```
수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생긴다. 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 된다.

흐름 제어는 위와 같이 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법이다.

TCP 버퍼
- 송신 측은 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송하고, 수신 측은 도착한 TCP 세그먼트를 애플리케이션이 읽을 때까지 버퍼에 보관한
```

## 1) Stop and Wait
매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법이다. 그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법이다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd6wyk4%2Fbtrlsi0dUFh%2FDSNUHLoKX8xYG4bg9YUkm1%2Fimg.png)

## 2) Sliding Window
수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.
 

### 윈도우 크기
```
최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다. 

윈도우 크기는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다. 
```
## 동작 방식
윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답(ACK)이 오면 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcTbios%2FbtrloyXkTF6%2FNCXRvhUJvAzXkz7xOiOLQ0%2Fimg.png)
- 최초로 수신자는 윈도우 사이즈를 7로 정한다.
- 송신자는 수신자의 확인 응답(ACK)을 받기 전까지 데이터를 보낸다.
- 수신자는 확인 응답(ACK)을 송신자에게 보내면, 슬라이딩 윈도우 사이즈을 충족할 수 있게끔 윈도우를 옆으로 옮긴다
- 이후 데이터를 다 받을 때까지 위 과정을 반복한다.

## 재전송

송신 측은 일정 시간 동안 수신 측으로부터 확인 응답(ACK)을 받지 못하면, 패킷을 재전송한다. 
만약, 송신 측에서 재전송을 했는데 패킷이 소실된 경우가 아니라 수신 측의 버퍼에 남는 공간 없는 경우면 문제가 생긴다. 
그래서 송신 측은 해결 응답(ACK)을 보내면서 남은 버퍼의 크기 (윈도우 크기)도 함께 보내 준다.

# 혼잡제어
```
데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다. 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다. 이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방할 수 있는데, 이것을 혼잡 제어라고 한다.

정리하자면, 흐름 제어는 송 수신 측 사이의 패킷 수를 제어하는 기능이라 할 수 있으며, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로우를 방지하는 기능이다.
```

# 혼잡 제어 기법 

## 1) AIMD (Additive Increse/Multicative Decrease)
우리 말로 직역하면 합 증가/곱 감소 방식이다. AIMD 방식은 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송한다. 

만약, 전송에 실패하면 윈도우 크기를 반으로 줄인다. 

윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점이 있다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbrHwax%2FbtrlqLVUHpr%2F7v1nCsodFMee5av1Yuzmxk%2Fimg.png)

## 2) Slow Start (느린 시작)
위에서 이야기했듯이 AIMD 방식은 윈도우 크기를 선형적으로 증가시키기 때문에, 제대로된 속도가 나오기까지 시간이 오래 걸린다. 반면, Slow Start는 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식이다.

이 방식은 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점이 있다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHOqHV%2FbtrlozPpRSA%2FDkpDCvOo0Sv3egRkeVW3W1%2Fimg.png)

## 3) Fast Retransmit 빠른 재전송

패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다. 

이런 상황이 발생했을 때 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 

그리고 이런 중복 ACK를 3개 받으면 재전송이 이루어진다. 

송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있다.

## 4) 빠른 회복 (Fast Recovery)
빠른 회복은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 

이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.

# 혼잡 제어 정책
TCP 에는 다양한 혼잡제어 정책이 존재하고 이런 혼잡 제어 정책들은 공통적으로 **혼잡이 발생하면 윈도우 크기를 줄이거나, 혹은 증가시키지 않으며 혼잡을 회피한다**라는 전제를 깔고 있다.

대표적인 혼잡 제어 정책은 Tahoe와 Reno가 있다.

Tahoe와 Reno는 기본적으로 처음에는 Slow Start 방식을 사용하다가 네트워크가 혼잡하다고 느껴졌을 때는 AIMD 방식으로 전환하는 방법을 사용하는 정책이다.

## TCP Tahoe

TCP Tahoe는 처음에는 Slow Start를 사용하여 자신의 윈도우 크기를 지수적으로 빠르게 증가시키다가 ssthresh를 만난 이후부터는 AIMD을 사용하여 선형적으로 윈도우 크기를 증가시킨다. 

그러다가 ACK Duplicated나 Timeout이 발생하면 네트워크에 혼잡이 발생했다고 판단하고, ssthresh와 자신의 윈도우 크기를 수정한다.

![image](https://user-images.githubusercontent.com/55661631/143570688-60cfb1e8-b23c-4e2c-b001-46240311041f.png)

위 그래프에서 청록색 선은 송신 측의 혼잡 윈도우 크기를, 굵은 검정선은 ssthresh 값을 보여주고 있다. 이 시나리오에서 송신 측의 혼잡 윈도우 크기는 8로 초기화 되었고, 그에 따라 ssthresh는 4로 설정되어 있다.

송신 측은 임계점을 만나기 전까지 Slow Start 방식을 사용하여 자신의 윈도우 크기를 증가시키다가 ssthresh를 넘어선 이후부터는 선형적으로 증가시키고 있다. 이 상황에서 3 ACK Duplicated나 Timeout과 같은 혼잡 상황을 만나면 어떻게 될까?

그래프를 보면 처음 혼잡 상황이 발생한 상태의 혼잡 윈도우 크기는 6이며, 그에 따라 ssthresh를 3으로 변경하고, 자신의 혼잡 윈도우 크기를 1로 줄였다. 이후 다시 Slow Start로 시작하여 임계점에 도달하면 AIMD를 시작한다.

이 정책은 한 번 혼잡 상황이 발생한 지점을 기억하고 그 지점이 가까워지지 않도록 합리적으로 조절하고 있다. 

하지만, 초반의 Slow Start 구간에 윈도우 크기를 늘릴 때 오래 걸린다는 단점이 있고, 혼잡 상황이 발생했을 때 다시 윈도우 크기를 1에서부터 시작해야 한다는 단점이 있다.

## TCP Reno

TCP Reno는 TCP Tahoe 이후에 나온 정책으로, Tahoe와 마찬가지로 Slow Start로 시작하여 임계점을 넘어서면 AIMD을 사용한다. 다만, Tahoe와는 다르게 3 ACK Duplicated와 Timeout 혼잡 상황을 구분한다.

![image](https://user-images.githubusercontent.com/55661631/143570706-234edf5e-f627-428d-8751-946b49b4afc2.png)

Reno는 3개의 중복 ACK가 발생했을 때, 윈도우 크기를 1로 줄이는 것이 아니라 AIMD처럼 반으로만 줄이고 sshthresh를 줄어든 윈도우 값으로 정하게 된다. 이 방식을 빠른 회복이라고 부른다.

그러나 Timeout에 의해서 데이터가 손실되면 Tahoe와 마찬가지로 윈도우 크기를 바로 1로 줄여버리고 Slow Start를 진행한다. 이때 ssthresh를 변경하지는 않는다.

즉, Reno는 ACK 중복은 Timeout에 비해 그리 큰 혼잡이 아니라고 가정하고 혼잡 윈도우 크기를 1로 줄이지도 않는다는 점에서 혼잡 상황의 우선 순위를 둔 정책이라 볼 수 있다.

# UDP

```
UDP는 전송계층의 비 연결 지향적 프로토콜입니다. 비 연결 지향적이란 연결을 위해 할당되는 논리적인 경로가 없고 각각의 패킷은 다른 경로로 전송되어 독립적인 관계를 지니게 되는 것을 말합니다. 이렇게 데이터를 서로 다른 경로로, 독립적으로 처리하는 프로토콜을 UDP라고 합니다.
```

## UDP를 사용하는 이유

- TCP는 신뢰성을 보장하지만 연결을 통해 시간 손실을 발생할 수 있습니다.
- TCP는 패킷이 누락되면 재전송을 해야합니다.
- 사진 또는 영상은 데이터의 일부가 누락돼도 문제가 발생하지 않기 때문에, TCP는 합리적인 방법이 되지 못합니다.
- 위와 같은 경우 전송 속도가 빠른 UDP를 사용합니다.

## UDP의 특징
- 비 연결형 서비스로 연결 없이 통신이 가능하며 데이터그램 방식을 제공합니다.
- 정보를 주고 받을 때, 정보를 보내거나 받는다는 신호 절차를 거치지 않습니다.
- 신뢰성 없는 데이터를 전송합니다.
- 패킷 관리가 필요합니다.
- 패킷 오버헤드가 적어 네트워크 부하가 감소되는 장점이 있습니다.
- 상대적으로 TCP보다 전송속도가 빠릅니다.

## UDP의 단점
- 데이터의 신뢰성이 없습니다.
- TCP와는 다르게 데이터를 쪼개주지 않아 애플리케이션 단에서 패킷을 쪼개야 합니다.

## TCP / UDP

1. 공통점

- 포트 번호를 이용하여 주소를 지정합니다.
- 데이터 오류 검사를 위한 체크섬이 존재합니다.

2. 차이점

![image](https://user-images.githubusercontent.com/55661631/143240402-81093a61-800f-459f-b2ac-5ee0a5089eb4.png)


# 참고

https://steady-coding.tistory.com/507

https://github.com/alstjgg/cs-study/blob/main/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%5BTCP%5D%203%20way%20handshake%EC%99%80%204%20way%20handshake.md