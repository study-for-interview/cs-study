# JWT(JSON WEB TOKEN)

JWT를 사용하기 이전에는 인증 체계를 위해서 COOKIE & SESSION을 이용했었습니다.

세션을 이용한 경우 만약 보안 문제(탈취당한 세션 ID 쿠키가 발생할 경우 등)가 발생하고 이를 해결하고자 한다면, 그냥 세션 저장소를 전부 지워버리면 됩니다. 

세션 ID가 탈취당했어도 해당 세션 ID가 현재 저장된 세션 저장소를 모두 지워버리면 탈취된 세션 ID로 서버에 접근해도 인증될 수단이 없습니다.

하지만 다르게 이야기하면 세션 저장소가 다른 모종의 이유로 장애가 난다면 인증 전체가 문제가 생겨 정상적인 사용자가 인증을 하지 못하는 불쾌한 경험을 선사합니다.

http의 장점이라고 할 수 있는 stateless를 위배합니다. 

서버의 세션 저장소라는 곳에 세션 ID, 즉 상태를 저장하는 상황이기 때문에 stateful 하게 되는 것이죠. 

stateful의 단점은 서버에 상태를 저장해 야하기 때문에 해당 서버를 늘리고 싶다고 생각할 때(scale out) 로그인 정보를 저장해야 하는 세션 저장소가 scale out 하기 이전의 서버에 있기 때문에 따로 또 세션 ID를 저장해야 하는 번거로움이 있습니다. 결국 중앙 세션 저장소를 필히 따로 만들어야 scale out의 문제가 최소화되겠죠.

![image](https://img1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/dkta/image/XuK2g62dt8lywEB30UfLfcTaVHE.png)

그럼 쿠키와 마찬가지로 세션을 사용했을 때의 단점은 다음과 같습니다.

- 세션 저장소의 문제가 발생하면 인증 체계가 무너져 이전에 다른 인증된 유저 또한 인증이 불가해진다.
- stateful 하기 때문에 http의 장점을 발휘하지 못하고 scale out에 걸림돌이 생긴다.
- 세션 저장소가 필수적으로 존재하기 때문에 이를 사용하기 위한 비용이 든다.
- 세션 ID가 탈취되었을 경우 대처는 가능하지만 클라이언트 인척 위장하는 보안의 약점이 있을 수 있다.
- 사용자가 많아질수록 메모리를 많이 차지하게 된다.
- "매번" 요청 시 세션 저장소를 조회해야 하는 단점이 있다.

 세션을 사용하면서 단점으로 꼽히는 것은 요청을 진행할 때마다 세션 저장소에 세션 ID를 조회하는 작업을 통해서 DB 접근이라는 로직이 한번 더 수행된다는 점, 이런 과정에서 그럼 이제는 더 좋은 방법이 없을까 하고 등장한 것이 JWT입니다.

JWT(Json Web Token)란?

 JWT(Json Web Token)은 위와 같은 일련의 과정 속에서 나타난 하나의 인터넷 표준 인증 방식입니다. 말 그대로 인증에 필요한 정보들을 Token에 담아 암호화시켜 사용하는 토큰인 것이죠.

 따라서 사실 기본적인 인증을 진행하는 구조는 Cookie때와 크게 다르지는 않습니다. 다만, 강조되는 점은 JWT는 서명된 토큰이라는 점입니다. 공개/개인 키를 쌍으로 사용하여 토큰에 서명할 경우 서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증할 수 있다는 이야기이죠.

 이러한 JWT의 구조 때문에 인증 정보를 담아 안전하게 인증을 시도하게끔 전달할 수 있는 것입니다.

 그럼 구조가 어떻게 되어있는지 확인해보겠습니다. JWT는 각각의 구성요소가 점(.)으로 구분이 되어있으며 구성 요소는 다음과 같습니다.  
- Header
- Payload
- Signature

아래처럼 각각의 구성 요소가 점(.)으로 구분되어있는 형태이죠.                        
![image](https://img1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/dkta/image/BuNsegetjYQAObzFyEWOfg8PMoc.png)

# HEADER

![image](https://img1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/dkta/image/a7eWSsZISsnstmJvZLfV1JyQxz4.png)

 header에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장합니다.

 지금 같은 경우에는 현재 토큰의 타입이 JWT이고, 앞서 이야기했던 개인키로 HS512 알고리즘이 적용되어 암호화가 되어있다고 확인할 수 있습니다.

 # Payload

![image](https://img1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/dkta/image/r_MS4Btp0GC6bDKmybDlO86SD6s.png)

payload에는 보통 Claim이라는 사용자에 대한, 혹은 토큰에 대한 property를 key-value의 형태로 저장합니다. Claim이라는 말 그대로 토큰에서 사용할 정보의 조각인 셈입니다.
  
사실 어떤 Claim값을 넣는지는 개발자의 마음입니다.
  
하지만 먼저 JWT의 표준 스펙을 알아보도록 하겠습니다.

표준 스펙상 key의 이름은 3글자로 되어있습니다. JWT의 핵심 목표는 사용자에 대한, 토큰에 대한 표현을 압축하는 것이기 때문에 이를 정의한 것이라고 볼 수 있겠네요.

1. iss (Issuer) : 토큰 발급자
2. sub (Subject) : 토큰 제목 - 토큰에서 사용자에 대한 식별 값이 됨
3. aud (Audience) : 토큰 대상자
4. exp (Expiration Time) : 토큰 만료 시간
5. nbf (Not Before) : 토큰 활성 날짜 (이 날짜 이전의 토큰은 활성화되지 않음을 보장)
6. iat (Issued At) : 토큰 발급 시간
7. jti (JWT Id) : JWT 토큰 식별자 (issuer가 여러 명일 때 이를 구분하기 위한 값)

이러한 표준 스펙으로 정의되어있는 Claim 스펙이 있다는 것이지, 꼭 이 7가지를 모두 포함해야 하는 것은 아니고, 상황에 따라 해당 서버가 가져야 할 인증 체계에 따라 사용하면 됩니다.

표준 스펙 외에도 필요하다 싶으면 추가해도 전혀 문제가 없습니다. 그건 개발자의 자유입니다.

예를 들어 Access Token과 Refresh Token을 구분하고 싶다면 "token_type"라는 커스텀한 Claim을 만들고 값을 아래와 같이 "access token"으로 두어 구분 지어도 괜찮습니다.

 다만 가장 중요한 것은 payload에 민감한 정보를 담지 않는 것입니다. 위에 header와 payload는 json이 디코딩되어있을 뿐이지 특별한 암호화가 걸려있는 것이 아니기 때문에 누구나 jwt를 가지고 디코딩을 한다면 header나 payload에 담긴 값을 알 수 있기 때문이죠.


아래의 디코딩 과정에서 보면 서버에서 생성한 JWT를 jwt.io라는 사이트에서 넣어서 확인한 결과입니다.

!(image)[https://img1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/dkta/image/l3QdV2Ty5BUnlM4sVnbToVH5B58.png]

JWT에서 header와 payload는 특별한 암호화 없이 흔히 사용할 수 있는 base64 인코딩을 사용하기 때문에 서버가 아니더라도 그 값들을 확인할 수 있습니다.

그래서 JWT는 단순히 "식별을 하기 위한" 정보만을 담아두어야 하는 것입니다.

# Signature

![image](https://img1.daumcdn.net/thumb/R1280x0.fpng/?fname=http://t1.daumcdn.net/brunch/service/user/dkta/image/YEjNagpqW-UV4dQPsPxZUHZIlwA.png)

가장 중요한 서명입니다. 물론 암호화가 되어있기 때문에 그 구조에 대한 이미지를 가져왔어요.

지금까지 Header와 Payload를 보여줄 때는 인코딩 되어있던 값들을 JWT에 담겨있는 것처럼 디코딩된 상태를 사용합니다. 

header를 디코딩한 값, payload를 디코딩한 값을 위처럼 합치고 이를 your-256-bit-secret 즉, 서버가 가지고 있는 개인키를 가지고 암호화되어있는 상태입니다.

따라서 signature는 서버에 있는 개인키로만 암호화를 풀 수 있으므로 다른 클라이언트는 임의로 Signature를 복호화할 수 없습니다.


잘 생각해보면 위에 설명한 내용만 봐도 어떻게 복호화해서 인증하는지는 쉽게 알 수 있을 것입니다.  

- JWT 토큰을 클라이언트가 서버로 요청과 동시에 전달한다.
- 서버가 가지고 있는 개인키를 가지고 Signature를 복호화한 다음 base64UrlEncode(header)가 JWT의 header값과 일치한 지, base64UrlEncode(payload) 와 일치한 지 확인하여 일치한다면 인증을 허용합니다.

만약 클라이언트가 payload에 담긴 식별자가 변조된 JWT로 요청을 하더라도 서버가 애초에 발급했던 Signature 안의 payload와 다르기 때문에 인증이 불가능해지겠죠.

## 장점

지금까지 쿠키와 세션을 넘어오면서 겪었던 모든 단점을 해결하는 것이 JWT인 것이기 때문에 단점들을 뒤집으면 JWT의 장점이라고 볼 수 있을 것 같습니다.

- 이미 토큰 자체가 인증된 정보이기 때문에 세션 저장소와 같은 별도의 인증 저장소가 "필수적"으로 필요하지 않습니다.
- 세션과는 다르게 클라이언트의 상태를 서버가 저장해 두지 않아도 됩니다.
- signature를 공통 키 개인키 암호화를 통해 막아두었기 때문에 데이터에 대한 보안성이 늘어납니다.
- 다른 서비스에 이용할 수 있는 공통적인 스펙으로써 사용할 수 있습니다.

처음 글부터 지금까지의 내용을 한 문장으로 요약하자면 stateful 해야 하는 세션의 단점을 보완하기 위해 만들어진 JWT는 별도의 세션 저장소를 강제하지 않기 때문에 stateless 하여 확장성이 뛰어나고, signature를 통한 보안성까지 갖추고 있습니다.


# JWT의 한계

단점
- 쿠키, 세션 때와는 다르게 base64 인코딩을 통한 정보를 전달하므로 전달량이 많다. 따라서 네트워크 전달 시 많은 데이터양으로 부하가 생길 수 있다.
- Payload에는 암호화가 되어있지 않기 때문에 민감 정보를 저장할 수 없다.
- 토큰이 탈취당하면 만료될 때까지 대처가 불가능하다.

세번째 단점에 대해서 조금 더 알아보자면,

## 토큰이  탈취당하면 만료될 때까지 대처가 불가능하다. 

 세션을 이야기할 때는 세션을 탈취당한다고 판단이 되었을 때 세션 저장소를 끊어서 탈취당한 세션 ID가 있더라도 세션 저장소에 그 값을 지워 탈취된 후의 상황을 보완할 수 있기는 했습니다. 근데 이건 서버에서 클라이언트의 상태를 저장하는 stateful 한 상황이고 지금은 stateless 해요.

 애초에 JWT를 발급해서 전달하고, 그 이후의 상황은 클라이언트가 관리하는 형태로 체계가 잡혀있기 때문에 서버가 탈취의 상황이 판단이 되어도 관리할 수 있는 방법이 없는 거죠. 
 그럼 이걸 어떻게 해결할까요?

 ### exp를 짧게 가져가자
 JWT의 스펙에서 알아보았던 exp, Expiration Time(만료시간)을 짧게 가져 가면 됩니다.

 물론 쿠키나 세션도 회사마다 만료시간을 두어 강제로 invalidate 하게 두는 경우도 있기는 합니다.
 
JWT도 탈취되었을 경우의 안정성 때문에 만료시간을 짧게 가져가기도 해요. 30분 혹은 1시간 정도의 짧은 토큰을 저장한다면, 만약 토큰이 탈취되어서 서버가 이를 강제로 끊지는 못하겠지만 짧은 시간만 유효하기 때문에 최소한의 보안성을 보장할 수 있겠습니다.

하지만, 항상 서비스를 사용하는 주체는 사용자이기 때문에 사용자의 입장에서 생각을 해봐야 합니다. 사용자 입장에서는 30분, 1시간만 유효하기 때문에 1시간 뒤에는 ID, PW를 또 입력해야 하는 불편한 경험을 느낄 수밖에 없습니다.

따라서 이 짧은 유효시간을 보완할 만한 두 가지 방법 또한 존재하기는 합니다.

## 짧은 JWT 유효시간을 보완하는 방법들

맹점은 서버가 JWT의 만료되기 직전의 유효시간을 보고 재발급을 어떤 방식으로 하느냐에 따라서 갈려요. 다양한 방법들이 있겠지만 대표적인 두 가지가 있습니다.

## 1. Sliding Session

 특정한 서비스를 계속 사용하고 있는 특정 유저에 대해 만료 시간을 연장시켜주는 방법입니다.

 어떤 글을 지속적으로 쓰고 있는 유저가 짧은 만료시간 때문에 글을 쓰다가 인증이 취소되어 글이 날아가면 아까 이야기한 불편한 경험을 제공하게 될 것입니다. Sliding Session을 사용하게 된다면, 글쓰기, 결제 등과 같은 특정 action을 유저가 행동하였을 때 새롭게 만료시간을 늘린 JWT를 다시 제공함으로써 만료시간을 연장하여 보완하는 방법입니다.

 다만, 접속이 단발성으로 일어난다면 Sliding Session으로 연장시켜줄 수 없는 상황이 생기고, 너무 긴 Access Token을 발급시켜준 상황이라면 Sliding Session 때문에 무한정 사용하는 상황이 발생할 수 있습니다.

## 2. Refresh Token

 가장 많이 사용하는 방법으로 JWT를 처음 발급할 때 Access Token과 함께 Refresh Token이라는 토큰을 발급하여 짧은 만료시간을 해결하는 방법입니다.

 짧은 시간이 아닌 비교적 긴 시간 (7일, 30일 등)의 만료시간을 가진 Refresh Token은 말 그대로 Access Token을 Refresh 해주는 것을 보장하는 토큰입니다. 만약 클라이언트가 Access Token이 만료됨을 본인이 인지하거나, 서버로부터 만료됨을 확인받았다면 Refresh Token으로 서버에게 새로운 Access Token을 발급하도록 요청하여 발급받는 방식입니다.

 Refresh Token Storage. 서버에서 Refresh Token을 저장하는 저장소인데요. 어떻게 보면 세션 저장소와 똑같은 역할을 한다고 생각하면 좋을 것 같습니다. 만료된 Access Token은 더 이상 인증의 역할을 못하니 Refresh Token을 서버로 전달하고, 이 Refresh Token이 서버의 token 저장소에 있는지 확인 후 Access Token을 발급하는 형태인데요.

 사실상 세션과 별반 차이 없이 특정 Storage에 I/O 작업이 발생하게 되기 때문에 Access Token이 지속되는 짧은 시간 동안만 I/O 작업이 일어나지 않는다이지, 세션의 단점을 하나 가져가는 셈이 됩니다.  다만 이를 사용함으로써 세션처럼 토큰 자체가 탈취되었다고 판단이 뒤면 Refresh Token Storage를 초기화하여 탈취된 토큰이 더 Refresh 못하도록 막는 등과 같은 부가 옵션이 생깁니다.

 하지만 세션의 I/O 작업에 대한 단점을 다 가져가니까 어차피 세션이랑 똑같은 거 아니야?라는 생각을 가지면 안 됩니다.

 세션은 항상 인증 요청을 할 때마다 세션 ID를 세션 저장소에 있는 세션 ID에 비교를 해야 해요. 예를 들어 30분에 1만 번의 요청을 한다고 했을 때 I/O는 1만 번 작동하겠죠.

 근데 Refresh Token은 Refresh 하는 그 순간 즉, 요청을 했는데 access token이 만료되었을 때만 I/O 작업을 해요. 30분에 1만 번의 요청을 한다고 했을 때 1만 번 access token으로 I/O 작업 없이 요청을 주고받고 30분이 지나면 딱 한번 Refresh 하기 위해서 요청을 하는 셈이죠.

참고 : 

https://brunch.co.kr/@jinyoungchoi95/1
